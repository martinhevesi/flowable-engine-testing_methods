<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Parser.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">org.flowable.common.engine.impl.de.odysseus.el.tree.impl</a> &gt; <span class="el_source">Parser.java</span></div><h1>Parser.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2006-2009 Odysseus Software GmbH
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.flowable.common.engine.impl.de.odysseus.el.tree.impl;

import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Builder.Feature.METHOD_INVOCATIONS;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Builder.Feature.NULL_PROPERTIES;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.COLON;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.COMMA;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.EMPTY;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.END_EVAL;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.EOF;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.FALSE;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.FLOAT;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.IDENTIFIER;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.INTEGER;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.LPAREN;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.MINUS;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.NOT;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.NULL;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.QUESTION;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.RBRACK;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.RPAREN;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.START_EVAL_DEFERRED;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.START_EVAL_DYNAMIC;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.STRING;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.TEXT;
import static org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol.TRUE;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;

import org.flowable.common.engine.impl.de.odysseus.el.misc.LocalMessages;
import org.flowable.common.engine.impl.de.odysseus.el.tree.FunctionNode;
import org.flowable.common.engine.impl.de.odysseus.el.tree.IdentifierNode;
import org.flowable.common.engine.impl.de.odysseus.el.tree.Tree;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Builder.Feature;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.ScanException;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Symbol;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.Scanner.Token;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstBinary;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstBoolean;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstBracket;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstChoice;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstComposite;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstDot;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstEval;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstFunction;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstIdentifier;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstMethod;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstNested;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstNode;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstNull;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstNumber;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstParameters;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstProperty;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstString;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstText;
import org.flowable.common.engine.impl.de.odysseus.el.tree.impl.ast.AstUnary;

/**
 * Handcrafted top-down parser.
 *
 * @author Christoph Beck
 */
public class Parser {
	/**
	 * Parse exception type
	 */
	@SuppressWarnings(&quot;serial&quot;)
	public static class ParseException extends Exception {
		final int position;
		final String encountered;
		final String expected;
		public ParseException(int position, String encountered, String expected) {
<span class="nc" id="L92">			super(LocalMessages.get(&quot;error.parse&quot;, position, encountered, expected));</span>
<span class="nc" id="L93">			this.position = position;</span>
<span class="nc" id="L94">			this.encountered = encountered;</span>
<span class="nc" id="L95">			this.expected = expected;</span>
<span class="nc" id="L96">		}</span>
	}

	/**
	 * Token type (used to store lookahead)
	 */
	private static final class LookaheadToken {
		final Token token;
		final int position;

<span class="nc" id="L106">		LookaheadToken(Token token, int position) {</span>
<span class="nc" id="L107">			this.token = token;</span>
<span class="nc" id="L108">			this.position = position;</span>
<span class="nc" id="L109">		}</span>
	}

<span class="nc" id="L112">	public enum ExtensionPoint {</span>
<span class="nc" id="L113">		OR,</span>
<span class="nc" id="L114">		AND,</span>
<span class="nc" id="L115">		EQ,</span>
<span class="nc" id="L116">		CMP,</span>
<span class="nc" id="L117">		ADD,</span>
<span class="nc" id="L118">		MUL,</span>
<span class="nc" id="L119">		UNARY,</span>
<span class="nc" id="L120">		LITERAL</span>
	}

	/**
	 * Provide limited support for syntax extensions.
	 */
    public abstract static class ExtensionHandler {
		private final ExtensionPoint point;
		
<span class="nc" id="L129">		public ExtensionHandler(ExtensionPoint point) {</span>
<span class="nc" id="L130">			this.point = point;</span>
<span class="nc" id="L131">		}</span>

		/**
		 * @return the extension point specifying where this syntax extension is active
		 */
		public ExtensionPoint getExtensionPoint() {
<span class="nc" id="L137">			return point;</span>
		}
		
		/**
		 * Called by the parser if it handles a extended token associated with this handler
		 * at the appropriate extension point.
		 * @param children
		 * @return abstract syntax tree node
		 */
		public abstract AstNode createAstNode(AstNode... children);
	}

<span class="nc" id="L149">	private static final String EXPR_FIRST =</span>
		IDENTIFIER + &quot;|&quot; + 
		STRING + &quot;|&quot; + FLOAT + &quot;|&quot; + INTEGER + &quot;|&quot; + TRUE + &quot;|&quot; + FALSE + &quot;|&quot; + NULL + &quot;|&quot; +
		MINUS + &quot;|&quot; + NOT + &quot;|&quot; + EMPTY + &quot;|&quot; +
		LPAREN;
	
	protected final Builder context;
	protected final Scanner scanner;

<span class="nc" id="L158">	private List&lt;IdentifierNode&gt; identifiers = Collections.emptyList();</span>
<span class="nc" id="L159">	private List&lt;FunctionNode&gt; functions = Collections.emptyList();</span>
<span class="nc" id="L160">	private List&lt;LookaheadToken&gt; lookahead = Collections.emptyList();</span>

	private Token token; // current token
	private int position;// current token's position
	
<span class="nc" id="L165">	protected Map&lt;Scanner.ExtensionToken, ExtensionHandler&gt; extensions = Collections.emptyMap();</span>

<span class="nc" id="L167">	public Parser(Builder context, String input) {</span>
<span class="nc" id="L168">		this.context = context;</span>
<span class="nc" id="L169">		this.scanner = createScanner(input);</span>
<span class="nc" id="L170">	}</span>

	protected Scanner createScanner(String expression) {
<span class="nc" id="L173">		return new Scanner(expression);</span>
	}

	public void putExtensionHandler(Scanner.ExtensionToken token, ExtensionHandler extension) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">		if (extensions.isEmpty()) {</span>
<span class="nc" id="L178">			extensions = new HashMap&lt;&gt;(16);</span>
		}
<span class="nc" id="L180">		extensions.put(token, extension);</span>
<span class="nc" id="L181">	}</span>
	
	protected ExtensionHandler getExtensionHandler(Token token) {
<span class="nc" id="L184">		return extensions.get(token);</span>
	}
	
	/**
	 * Parse an integer literal.
	 * @param string string to parse
	 * @return &lt;code&gt;Long.valueOf(string)&lt;/code&gt;
	 */
	protected Number parseInteger(String string) throws ParseException {
		try {
<span class="nc" id="L194">			return Long.valueOf(string);</span>
<span class="nc" id="L195">		} catch (NumberFormatException e) {</span>
<span class="nc" id="L196">			fail(INTEGER);</span>
<span class="nc" id="L197">			return null;</span>
		}
	}
	
	/**
	 * Parse a floating point literal.
	 * @param string string to parse
	 * @return &lt;code&gt;Double.valueOf(string)&lt;/code&gt;
	 */
	protected Number parseFloat(String string) throws ParseException {
		try {
<span class="nc" id="L208">			return Double.valueOf(string);</span>
<span class="nc" id="L209">		} catch (NumberFormatException e) {</span>
<span class="nc" id="L210">			fail(FLOAT);</span>
<span class="nc" id="L211">			return null;</span>
		}
	}

	protected AstBinary createAstBinary(AstNode left, AstNode right, AstBinary.Operator operator) {
<span class="nc" id="L216">		return new AstBinary(left, right, operator);</span>
	}
	
	protected AstBracket createAstBracket(AstNode base, AstNode property, boolean lvalue, boolean strict) {
<span class="nc" id="L220">		return new AstBracket(base, property, lvalue, strict, context.isEnabled(Feature.IGNORE_RETURN_TYPE));</span>
	}
	
	protected AstChoice createAstChoice(AstNode question, AstNode yes, AstNode no) {
<span class="nc" id="L224">		return new AstChoice(question, yes, no);</span>
	}
	
	protected AstComposite createAstComposite(List&lt;AstNode&gt; nodes) {
<span class="nc" id="L228">		return new AstComposite(nodes);</span>
	}
	
	protected AstDot createAstDot(AstNode base, String property, boolean lvalue) {
<span class="nc" id="L232">		return new AstDot(base, property, lvalue, context.isEnabled(Feature.IGNORE_RETURN_TYPE));</span>
	}
	
	protected AstFunction createAstFunction(String name, int index, AstParameters params) {
<span class="nc" id="L236">		return new AstFunction(name, index, params, context.isEnabled(Feature.VARARGS));</span>
	}

	protected AstIdentifier createAstIdentifier(String name, int index) {
<span class="nc" id="L240">		return new AstIdentifier(name, index, context.isEnabled(Feature.IGNORE_RETURN_TYPE));</span>
	}
	
	protected AstMethod createAstMethod(AstProperty property, AstParameters params) {
<span class="nc" id="L244">		return new AstMethod(property, params);</span>
	}
	
	protected AstUnary createAstUnary(AstNode child, AstUnary.Operator operator) {
<span class="nc" id="L248">		return new AstUnary(child, operator);</span>
	}

	protected final List&lt;FunctionNode&gt; getFunctions() {
<span class="nc" id="L252">		return functions;</span>
	}
	
	protected final List&lt;IdentifierNode&gt; getIdentifiers() {
<span class="nc" id="L256">		return identifiers;</span>
	}

	protected final Token getToken() {
<span class="nc" id="L260">		return token;</span>
	}

	/**
	 * throw exception
	 */
	protected void fail(String expected) throws ParseException {
<span class="nc" id="L267">		throw new ParseException(position, &quot;'&quot; + token.getImage() + &quot;'&quot;, expected);</span>
	}

	/**
	 * throw exception
	 */
	protected void fail(Symbol expected) throws ParseException {
<span class="nc" id="L274">		fail(expected.toString());</span>
<span class="nc" id="L275">	}</span>

	/**
	 * get lookahead symbol.
	 */
	protected final Token lookahead(int index) throws ScanException, ParseException {
<span class="nc bnc" id="L281" title="All 2 branches missed.">		if (lookahead.isEmpty()) {</span>
<span class="nc" id="L282">			lookahead = new LinkedList&lt;&gt;();</span>
		}
<span class="nc bnc" id="L284" title="All 2 branches missed.">		while (index &gt;= lookahead.size()) {</span>
<span class="nc" id="L285">			lookahead.add(new LookaheadToken(scanner.next(), scanner.getPosition()));</span>
		}
<span class="nc" id="L287">		return lookahead.get(index).token;</span>
	}

	/**
	 * consume current token (get next token).
	 * @return the consumed token (which was the current token when calling this method)
	 */
	protected final Token consumeToken() throws ScanException, ParseException {
<span class="nc" id="L295">		Token result = token;</span>
<span class="nc bnc" id="L296" title="All 2 branches missed.">		if (lookahead.isEmpty()) {</span>
<span class="nc" id="L297">			token = scanner.next();</span>
<span class="nc" id="L298">			position = scanner.getPosition();</span>
		} else {
<span class="nc" id="L300">			LookaheadToken next = lookahead.remove(0);</span>
<span class="nc" id="L301">			token = next.token;</span>
<span class="nc" id="L302">			position = next.position;</span>
		}
<span class="nc" id="L304">		return result;</span>
	}

	/**
	 * consume current token (get next token); throw exception if the current token doesn't
	 * match the expected symbol.
	 */
	protected final Token consumeToken(Symbol expected) throws ScanException, ParseException {
<span class="nc bnc" id="L312" title="All 2 branches missed.">		if (token.getSymbol() != expected) {</span>
<span class="nc" id="L313">			fail(expected);</span>
		}
<span class="nc" id="L315">		return consumeToken();</span>
	}
	
	/**
	 * tree := text? ((dynamic text?)+ | (deferred text?)+)? 
	 */
	public Tree tree() throws ScanException, ParseException {
<span class="nc" id="L322">		consumeToken();</span>
<span class="nc" id="L323">		AstNode t = text();</span>
<span class="nc bnc" id="L324" title="All 2 branches missed.">		if (token.getSymbol() == EOF) {</span>
<span class="nc bnc" id="L325" title="All 2 branches missed.">			if (t == null) {</span>
<span class="nc" id="L326">				t = new AstText(&quot;&quot;);</span>
			}
<span class="nc" id="L328">			return new Tree(t, functions, identifiers, false);</span>
		}
<span class="nc" id="L330">		AstEval e = eval();</span>
<span class="nc bnc" id="L331" title="All 4 branches missed.">		if (token.getSymbol() == EOF &amp;&amp; t == null) {</span>
<span class="nc" id="L332">			return new Tree(e, functions, identifiers, e.isDeferred());</span>
		}
<span class="nc" id="L334">		ArrayList&lt;AstNode&gt; list = new ArrayList&lt;&gt;();</span>
<span class="nc bnc" id="L335" title="All 2 branches missed.">		if (t != null) {</span>
<span class="nc" id="L336">			list.add(t);</span>
		}
<span class="nc" id="L338">		list.add(e);</span>
<span class="nc" id="L339">		t = text();</span>
<span class="nc bnc" id="L340" title="All 2 branches missed.">		if (t != null) {</span>
<span class="nc" id="L341">			list.add(t);</span>
		}
<span class="nc bnc" id="L343" title="All 2 branches missed.">		while (token.getSymbol() != EOF) {</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">			if (e.isDeferred()) {</span>
<span class="nc" id="L345">				list.add(eval(true, true));</span>
			} else {
<span class="nc" id="L347">				list.add(eval(true, false));</span>
			}
<span class="nc" id="L349">			t = text();</span>
<span class="nc bnc" id="L350" title="All 2 branches missed.">			if (t != null) {</span>
<span class="nc" id="L351">				list.add(t);</span>
			}
		}
<span class="nc" id="L354">		return new Tree(createAstComposite(list), functions, identifiers, e.isDeferred());</span>
	}

	/**
	 * text := &amp;lt;TEXT&amp;gt;
	 */
	protected AstNode text() throws ScanException, ParseException {
<span class="nc" id="L361">		AstNode v = null;</span>
<span class="nc bnc" id="L362" title="All 2 branches missed.">		if (token.getSymbol() == TEXT) {</span>
<span class="nc" id="L363">			v = new AstText(token.getImage());</span>
<span class="nc" id="L364">			consumeToken();</span>
		}
<span class="nc" id="L366">		return v;</span>
	}

	/**
	 * eval := dynamic | deferred
	 */
	protected AstEval eval() throws ScanException, ParseException {
<span class="nc" id="L373">		AstEval e = eval(false, false);</span>
<span class="nc bnc" id="L374" title="All 2 branches missed.">		if (e == null) {</span>
<span class="nc" id="L375">			e = eval(false, true);</span>
<span class="nc bnc" id="L376" title="All 2 branches missed.">			if (e == null) {</span>
<span class="nc" id="L377">				fail(START_EVAL_DEFERRED + &quot;|&quot; + START_EVAL_DYNAMIC);</span>
			}
		}
<span class="nc" id="L380">		return e;</span>
	}

	/**
	 * dynmamic := &amp;lt;START_EVAL_DYNAMIC&amp;gt; expr &amp;lt;END_EVAL&amp;gt;
	 * deferred := &amp;lt;START_EVAL_DEFERRED&amp;gt; expr &amp;lt;END_EVAL&amp;gt;
	 */
	protected AstEval eval(boolean required, boolean deferred) throws ScanException, ParseException {
<span class="nc" id="L388">		AstEval v = null;</span>
<span class="nc bnc" id="L389" title="All 2 branches missed.">		Symbol start_eval = deferred ? START_EVAL_DEFERRED : START_EVAL_DYNAMIC;</span>
<span class="nc bnc" id="L390" title="All 2 branches missed.">		if (token.getSymbol() == start_eval) {</span>
<span class="nc" id="L391">			consumeToken();</span>
<span class="nc" id="L392">			v = new AstEval(expr(true), deferred);</span>
<span class="nc" id="L393">			consumeToken(END_EVAL);</span>
<span class="nc bnc" id="L394" title="All 2 branches missed.">		} else if (required) {</span>
<span class="nc" id="L395">			fail(start_eval);</span>
		}
<span class="nc" id="L397">		return v;</span>
	}

	/**
	 * expr := or (&amp;lt;QUESTION&amp;gt; expr &amp;lt;COLON&amp;gt; expr)?
	 */
	protected AstNode expr(boolean required) throws ScanException, ParseException {
<span class="nc" id="L404">		AstNode v = or(required);</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L406">			return null;</span>
		}
<span class="nc bnc" id="L408" title="All 2 branches missed.">		if (token.getSymbol() == QUESTION) {</span>
<span class="nc" id="L409">			consumeToken();</span>
<span class="nc" id="L410">			AstNode a = expr(true);</span>
<span class="nc" id="L411">			consumeToken(COLON);</span>
<span class="nc" id="L412">			AstNode b = expr(true);</span>
<span class="nc" id="L413">			v = createAstChoice(v, a, b);</span>
		}
<span class="nc" id="L415">		return v;</span>
	}

	/**
	 * or := and (&amp;lt;OR&amp;gt; and)*
	 */
	protected AstNode or(boolean required) throws ScanException, ParseException {
<span class="nc" id="L422">		AstNode v = and(required);</span>
<span class="nc bnc" id="L423" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L424">			return null;</span>
		}
		while (true) {
<span class="nc bnc" id="L427" title="All 3 branches missed.">			switch (token.getSymbol()) {</span>
				case OR:
<span class="nc" id="L429">					consumeToken();</span>
<span class="nc" id="L430">					v = createAstBinary(v, and(true), AstBinary.OR);</span>
<span class="nc" id="L431">					break;</span>
				case EXTENSION:
<span class="nc bnc" id="L433" title="All 2 branches missed.">					if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.OR) {</span>
<span class="nc" id="L434">						v = getExtensionHandler(consumeToken()).createAstNode(v, and(true));</span>
<span class="nc" id="L435">						break;</span>
					}
				default:
<span class="nc" id="L438">					return v;</span>
			}
		}
	}

	/**
	 * and := eq (&amp;lt;AND&amp;gt; eq)*
	 */
	protected AstNode and(boolean required) throws ScanException, ParseException {
<span class="nc" id="L447">		AstNode v = eq(required);</span>
<span class="nc bnc" id="L448" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L449">			return null;</span>
		}
		while (true) {
<span class="nc bnc" id="L452" title="All 3 branches missed.">			switch (token.getSymbol()) {</span>
				case AND:
<span class="nc" id="L454">					consumeToken();</span>
<span class="nc" id="L455">					v = createAstBinary(v, eq(true), AstBinary.AND);</span>
<span class="nc" id="L456">					break;</span>
				case EXTENSION:
<span class="nc bnc" id="L458" title="All 2 branches missed.">					if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.AND) {</span>
<span class="nc" id="L459">						v = getExtensionHandler(consumeToken()).createAstNode(v, eq(true));</span>
<span class="nc" id="L460">						break;</span>
					}
				default:
<span class="nc" id="L463">					return v;</span>
			}
		}
	}

	/**
	 * eq := cmp (&amp;lt;EQ&amp;gt; cmp | &amp;lt;NE&amp;gt; cmp)*
	 */
	protected AstNode eq(boolean required) throws ScanException, ParseException {
<span class="nc" id="L472">		AstNode v = cmp(required);</span>
<span class="nc bnc" id="L473" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L474">			return null;</span>
		}
		while (true) {
<span class="nc bnc" id="L477" title="All 4 branches missed.">			switch (token.getSymbol()) {</span>
				case EQ:
<span class="nc" id="L479">					consumeToken();</span>
<span class="nc" id="L480">					v = createAstBinary(v, cmp(true), AstBinary.EQ);</span>
<span class="nc" id="L481">					break;</span>
				case NE:
<span class="nc" id="L483">					consumeToken();</span>
<span class="nc" id="L484">					v = createAstBinary(v, cmp(true), AstBinary.NE);</span>
<span class="nc" id="L485">					break;</span>
				case EXTENSION:
<span class="nc bnc" id="L487" title="All 2 branches missed.">					if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.EQ) {</span>
<span class="nc" id="L488">						v = getExtensionHandler(consumeToken()).createAstNode(v, cmp(true));</span>
<span class="nc" id="L489">						break;</span>
					}
				default:
<span class="nc" id="L492">					return v;</span>
			}
		}
	}
	
	/**
	 * cmp := add (&amp;lt;LT&amp;gt; add | &amp;lt;LE&amp;gt; add | &amp;lt;GE&amp;gt; add | &amp;lt;GT&amp;gt; add)*
	 */
	protected AstNode cmp(boolean required) throws ScanException, ParseException {
<span class="nc" id="L501">		AstNode v = add(required);</span>
<span class="nc bnc" id="L502" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L503">			return null;</span>
		}
		while (true) {
<span class="nc bnc" id="L506" title="All 6 branches missed.">			switch (token.getSymbol()) {</span>
				case LT:
<span class="nc" id="L508">					consumeToken();</span>
<span class="nc" id="L509">					v = createAstBinary(v, add(true), AstBinary.LT);</span>
<span class="nc" id="L510">					break;</span>
				case LE:
<span class="nc" id="L512">					consumeToken();</span>
<span class="nc" id="L513">					v = createAstBinary(v, add(true), AstBinary.LE);</span>
<span class="nc" id="L514">					break;</span>
				case GE:
<span class="nc" id="L516">					consumeToken();</span>
<span class="nc" id="L517">					v = createAstBinary(v, add(true), AstBinary.GE);</span>
<span class="nc" id="L518">					break;</span>
				case GT:
<span class="nc" id="L520">					consumeToken();</span>
<span class="nc" id="L521">					v = createAstBinary(v, add(true), AstBinary.GT);</span>
<span class="nc" id="L522">					break;</span>
				case EXTENSION:
<span class="nc bnc" id="L524" title="All 2 branches missed.">					if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.CMP) {</span>
<span class="nc" id="L525">						v = getExtensionHandler(consumeToken()).createAstNode(v, add(true));</span>
<span class="nc" id="L526">						break;</span>
					}
				default:
<span class="nc" id="L529">					return v;</span>
			}
		}
	}

	/**
	 * add := add (&amp;lt;PLUS&amp;gt; mul | &amp;lt;MINUS&amp;gt; mul)*
	 */
	protected AstNode add(boolean required) throws ScanException, ParseException {
<span class="nc" id="L538">		AstNode v = mul(required);</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L540">			return null;</span>
		}
		while (true) {
<span class="nc bnc" id="L543" title="All 4 branches missed.">			switch (token.getSymbol()) {</span>
				case PLUS:
<span class="nc" id="L545">					consumeToken();</span>
<span class="nc" id="L546">					v = createAstBinary(v, mul(true), AstBinary.ADD);</span>
<span class="nc" id="L547">					break;</span>
				case MINUS:
<span class="nc" id="L549">					consumeToken();</span>
<span class="nc" id="L550">					v = createAstBinary(v, mul(true), AstBinary.SUB);</span>
<span class="nc" id="L551">					break;</span>
				case EXTENSION:
<span class="nc bnc" id="L553" title="All 2 branches missed.">					if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.ADD) {</span>
<span class="nc" id="L554">						v = getExtensionHandler(consumeToken()).createAstNode(v, mul(true));</span>
<span class="nc" id="L555">						break;</span>
					}
				default:
<span class="nc" id="L558">					return v;</span>
			}
		}
	}

	/**
	 * mul := unary (&amp;lt;MUL&amp;gt; unary | &amp;lt;DIV&amp;gt; unary | &amp;lt;MOD&amp;gt; unary)*
	 */
	protected AstNode mul(boolean required) throws ScanException, ParseException {
<span class="nc" id="L567">		AstNode v = unary(required);</span>
<span class="nc bnc" id="L568" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L569">			return null;</span>
		}
		while (true) {
<span class="nc bnc" id="L572" title="All 5 branches missed.">			switch (token.getSymbol()) {</span>
				case MUL:
<span class="nc" id="L574">					consumeToken();</span>
<span class="nc" id="L575">					v = createAstBinary(v, unary(true), AstBinary.MUL);</span>
<span class="nc" id="L576">					break;</span>
				case DIV:
<span class="nc" id="L578">					consumeToken();</span>
<span class="nc" id="L579">					v = createAstBinary(v, unary(true), AstBinary.DIV);</span>
<span class="nc" id="L580">					break;</span>
				case MOD:
<span class="nc" id="L582">					consumeToken();</span>
<span class="nc" id="L583">					v = createAstBinary(v, unary(true), AstBinary.MOD);</span>
<span class="nc" id="L584">					break;</span>
				case EXTENSION:
<span class="nc bnc" id="L586" title="All 2 branches missed.">					if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.MUL) {</span>
<span class="nc" id="L587">						v = getExtensionHandler(consumeToken()).createAstNode(v, unary(true));</span>
<span class="nc" id="L588">						break;</span>
					}
				default:
<span class="nc" id="L591">					return v;</span>
			}
		}
	}

	/**
	 * unary := &amp;lt;NOT&amp;gt; unary | &amp;lt;MINUS&amp;gt; unary | &amp;lt;EMPTY&amp;gt; unary | value
	 */
	protected AstNode unary(boolean required) throws ScanException, ParseException {
<span class="nc" id="L600">		AstNode v = null;</span>
<span class="nc bnc" id="L601" title="All 5 branches missed.">		switch (token.getSymbol()) {</span>
			case NOT:
<span class="nc" id="L603">				consumeToken();</span>
<span class="nc" id="L604">				v = createAstUnary(unary(true), AstUnary.NOT);</span>
<span class="nc" id="L605">				break;</span>
			case MINUS:
<span class="nc" id="L607">				consumeToken();</span>
<span class="nc" id="L608">				v = createAstUnary(unary(true), AstUnary.NEG);</span>
<span class="nc" id="L609">				break;</span>
			case EMPTY:
<span class="nc" id="L611">				consumeToken();</span>
<span class="nc" id="L612">				v = createAstUnary(unary(true), AstUnary.EMPTY);</span>
<span class="nc" id="L613">				break;</span>
			case EXTENSION:
<span class="nc bnc" id="L615" title="All 2 branches missed.">				if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.UNARY) {</span>
<span class="nc" id="L616">					v = getExtensionHandler(consumeToken()).createAstNode(unary(true));</span>
<span class="nc" id="L617">					break;</span>
				}
			default:
<span class="nc" id="L620">				v = value();</span>
		}
<span class="nc bnc" id="L622" title="All 4 branches missed.">		if (v == null &amp;&amp; required) {</span>
<span class="nc" id="L623">			fail(EXPR_FIRST);</span>
		}
<span class="nc" id="L625">		return v;</span>
	}

	/**
	 * value := (nonliteral | literal) (&amp;lt;DOT&amp;gt; &amp;lt;IDENTIFIER&amp;gt; | &amp;lt;LBRACK&amp;gt; expr &amp;lt;RBRACK&amp;gt;)*
	 */
	protected AstNode value() throws ScanException, ParseException {
<span class="nc" id="L632">		boolean lvalue = true;</span>
<span class="nc" id="L633">		AstNode v = nonliteral();</span>
<span class="nc bnc" id="L634" title="All 2 branches missed.">		if (v == null) {</span>
<span class="nc" id="L635">			v = literal();</span>
<span class="nc bnc" id="L636" title="All 2 branches missed.">			if (v == null) {</span>
<span class="nc" id="L637">				return null;</span>
			}
<span class="nc" id="L639">			lvalue = false;</span>
		}
		while (true) {
<span class="nc bnc" id="L642" title="All 3 branches missed.">			switch (token.getSymbol()) {</span>
				case DOT:
<span class="nc" id="L644">					consumeToken();</span>
<span class="nc" id="L645">					String name = consumeToken(IDENTIFIER).getImage();</span>
<span class="nc" id="L646">					AstDot dot = createAstDot(v, name, lvalue);</span>
<span class="nc bnc" id="L647" title="All 4 branches missed.">					if (token.getSymbol() == LPAREN &amp;&amp; context.isEnabled(METHOD_INVOCATIONS)) {</span>
<span class="nc" id="L648">						v = createAstMethod(dot, params());</span>
					} else {
<span class="nc" id="L650">						v = dot;</span>
					}
<span class="nc" id="L652">					break;</span>
				case LBRACK:
<span class="nc" id="L654">					consumeToken();</span>
<span class="nc" id="L655">					AstNode property = expr(true);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">					boolean strict = !context.isEnabled(NULL_PROPERTIES);</span>
<span class="nc" id="L657">					consumeToken(RBRACK);</span>
<span class="nc" id="L658">					AstBracket bracket = createAstBracket(v, property, lvalue, strict);</span>
<span class="nc bnc" id="L659" title="All 4 branches missed.">					if (token.getSymbol() == LPAREN &amp;&amp; context.isEnabled(METHOD_INVOCATIONS)) {</span>
<span class="nc" id="L660">						v = createAstMethod(bracket, params());</span>
					} else {
<span class="nc" id="L662">						v = bracket;</span>
					}
<span class="nc" id="L664">					break;</span>
				default:
<span class="nc" id="L666">					return v;</span>
			}
		}
	}

	/**
	 * nonliteral := &amp;lt;IDENTIFIER&amp;gt; | function | &amp;lt;LPAREN&amp;gt; expr &amp;lt;RPAREN&amp;gt;
	 * function   := (&amp;lt;IDENTIFIER&amp;gt; &amp;lt;COLON&amp;gt;)? &amp;lt;IDENTIFIER&amp;gt; &amp;lt;LPAREN&amp;gt; list? &amp;lt;RPAREN&amp;gt;
	 */
	protected AstNode nonliteral() throws ScanException, ParseException {
<span class="nc" id="L676">		AstNode v = null;</span>
<span class="nc bnc" id="L677" title="All 3 branches missed.">		switch (token.getSymbol()) {</span>
			case IDENTIFIER:
<span class="nc" id="L679">				String name = consumeToken().getImage();</span>
<span class="nc bnc" id="L680" title="All 6 branches missed.">				if (token.getSymbol() == COLON &amp;&amp; lookahead(0).getSymbol() == IDENTIFIER &amp;&amp; lookahead(1).getSymbol() == LPAREN) { // ns:f(...)</span>
<span class="nc" id="L681">					consumeToken();</span>
<span class="nc" id="L682">					name += &quot;:&quot; + token.getImage();</span>
<span class="nc" id="L683">					consumeToken();</span>
				}
<span class="nc bnc" id="L685" title="All 2 branches missed.">				if (token.getSymbol() == LPAREN) { // function</span>
<span class="nc" id="L686">					v = function(name, params());</span>
				} else { // identifier
<span class="nc" id="L688">					v = identifier(name);</span>
				}
<span class="nc" id="L690">				break;</span>
			case LPAREN:
<span class="nc" id="L692">				consumeToken();</span>
<span class="nc" id="L693">				v = expr(true);</span>
<span class="nc" id="L694">				consumeToken(RPAREN);</span>
<span class="nc" id="L695">				v = new AstNested(v);</span>
				break;
		}
<span class="nc" id="L698">		return v;</span>
	}

	/**
	 * params := &amp;lt;LPAREN&amp;gt; (expr (&amp;lt;COMMA&amp;gt; expr)*)? &amp;lt;RPAREN&amp;gt;
	 */
	protected AstParameters params() throws ScanException, ParseException {
<span class="nc" id="L705">		consumeToken(LPAREN);</span>
<span class="nc" id="L706">		List&lt;AstNode&gt; l = Collections.emptyList();</span>
<span class="nc" id="L707">		AstNode v = expr(false);</span>
<span class="nc bnc" id="L708" title="All 2 branches missed.">		if (v != null) {</span>
<span class="nc" id="L709">			l = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L710">			l.add(v);</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">			while (token.getSymbol() == COMMA) {</span>
<span class="nc" id="L712">				consumeToken();</span>
<span class="nc" id="L713">				l.add(expr(true));</span>
			}
		}
<span class="nc" id="L716">		consumeToken(RPAREN);</span>
<span class="nc" id="L717">		return new AstParameters(l);</span>
	}
	
	/**
	 * literal := &amp;lt;TRUE&amp;gt; | &amp;lt;FALSE&amp;gt; | &amp;lt;STRING&amp;gt; | &amp;lt;INTEGER&amp;gt; | &amp;lt;FLOAT&amp;gt; | &amp;lt;NULL&amp;gt;
	 */
	protected AstNode literal() throws ScanException, ParseException {
<span class="nc" id="L724">		AstNode v = null;</span>
<span class="nc bnc" id="L725" title="All 8 branches missed.">		switch (token.getSymbol()) {</span>
			case TRUE:
<span class="nc" id="L727">				v = new AstBoolean(true);</span>
<span class="nc" id="L728">				consumeToken();</span>
<span class="nc" id="L729">				break;</span>
			case FALSE:
<span class="nc" id="L731">				v = new AstBoolean(false);</span>
<span class="nc" id="L732">				consumeToken();</span>
<span class="nc" id="L733">				break;</span>
			case STRING:
<span class="nc" id="L735">				v = new AstString(token.getImage());</span>
<span class="nc" id="L736">				consumeToken();</span>
<span class="nc" id="L737">				break;</span>
			case INTEGER:
<span class="nc" id="L739">				v = new AstNumber(parseInteger(token.getImage()));</span>
<span class="nc" id="L740">				consumeToken();</span>
<span class="nc" id="L741">				break;</span>
			case FLOAT:
<span class="nc" id="L743">				v = new AstNumber(parseFloat(token.getImage()));</span>
<span class="nc" id="L744">				consumeToken();</span>
<span class="nc" id="L745">				break;			</span>
			case NULL:
<span class="nc" id="L747">				v = new AstNull();</span>
<span class="nc" id="L748">				consumeToken();</span>
<span class="nc" id="L749">				break;</span>
			case EXTENSION:
<span class="nc bnc" id="L751" title="All 2 branches missed.">				if (getExtensionHandler(token).getExtensionPoint() == ExtensionPoint.LITERAL) {</span>
<span class="nc" id="L752">					v = getExtensionHandler(consumeToken()).createAstNode();</span>
					break;
				}
		}
<span class="nc" id="L756">		return v;</span>
	}

	protected final AstFunction function(String name, AstParameters params) {
<span class="nc bnc" id="L760" title="All 2 branches missed.">		if (functions.isEmpty()) {</span>
<span class="nc" id="L761">			functions = new ArrayList&lt;&gt;(4);</span>
		}
<span class="nc" id="L763">		AstFunction function = createAstFunction(name, functions.size(), params);</span>
<span class="nc" id="L764">		functions.add(function);</span>
<span class="nc" id="L765">		return function;</span>
	}
	
	protected final AstIdentifier identifier(String name) {
<span class="nc bnc" id="L769" title="All 2 branches missed.">		if (identifiers.isEmpty()) {</span>
<span class="nc" id="L770">			identifiers = new ArrayList&lt;&gt;(4);</span>
		}
<span class="nc" id="L772">		AstIdentifier identifier = createAstIdentifier(name, identifiers.size());</span>
<span class="nc" id="L773">		identifiers.add(identifier);</span>
<span class="nc" id="L774">		return identifier;</span>
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>