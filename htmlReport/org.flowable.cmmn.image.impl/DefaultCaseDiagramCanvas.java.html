<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultCaseDiagramCanvas.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">org.flowable.cmmn.image.impl</a> &gt; <span class="el_source">DefaultCaseDiagramCanvas.java</span></div><h1>DefaultCaseDiagramCanvas.java</h1><pre class="source lang-java linenums">/* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.flowable.cmmn.image.impl;

import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Graphics2D;
import java.awt.Paint;
import java.awt.Point;
import java.awt.Polygon;
import java.awt.RenderingHints;
import java.awt.Shape;
import java.awt.Stroke;
import java.awt.font.LineBreakMeasurer;
import java.awt.font.TextAttribute;
import java.awt.font.TextLayout;
import java.awt.geom.AffineTransform;
import java.awt.geom.Ellipse2D;
import java.awt.geom.Line2D;
import java.awt.geom.Path2D;
import java.awt.geom.PathIterator;
import java.awt.geom.Rectangle2D;
import java.awt.geom.RoundRectangle2D;
import java.awt.image.BufferedImage;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.text.AttributedCharacterIterator;
import java.text.AttributedString;
import java.util.ArrayList;
import java.util.List;

import javax.imageio.ImageIO;

import org.flowable.cmmn.image.exception.FlowableImageException;
import org.flowable.cmmn.image.util.ReflectUtil;
import org.flowable.cmmn.model.GraphicInfo;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Represents a canvas on which CMMN 1.1 constructs can be drawn.
 *
 * Some of the icons used are licensed under a Creative Commons Attribution 2.5 License, see http://www.famfamfam.com/lab/icons/silk/
 *
 * @see DefaultCaseDiagramGenerator
 * @author Tijs Rademakers
 */
public class DefaultCaseDiagramCanvas {

<span class="nc" id="L65">    protected static final Logger LOGGER = LoggerFactory.getLogger(DefaultCaseDiagramCanvas.class);</span>

<span class="nc" id="L67">    public enum SHAPE_TYPE {</span>
<span class="nc" id="L68">        Rectangle, Rhombus, Ellipse</span>
    }

    // Predefined sized
    protected static final int ARROW_WIDTH = 5;
    protected static final int CONDITIONAL_INDICATOR_WIDTH = 16;
    protected static final int DEFAULT_INDICATOR_WIDTH = 10;
    protected static final int MARKER_WIDTH = 12;
    protected static final int FONT_SIZE = 11;
    protected static final int FONT_SPACING = 2;
    protected static final int TEXT_PADDING = 3;
    protected static final int ANNOTATION_TEXT_PADDING = 7;
    protected static final int LINE_HEIGHT = FONT_SIZE + FONT_SPACING;

    // Colors
<span class="nc" id="L83">    protected static final Color TASK_BOX_COLOR = new Color(249, 249, 249);</span>
<span class="nc" id="L84">    protected static final Color SUBPROCESS_BOX_COLOR = new Color(255, 255, 255);</span>
<span class="nc" id="L85">    protected static final Color EVENT_COLOR = new Color(255, 255, 255);</span>
<span class="nc" id="L86">    protected static final Color CONNECTION_COLOR = new Color(88, 88, 88);</span>
<span class="nc" id="L87">    protected static final Color CONDITIONAL_INDICATOR_COLOR = new Color(255, 255, 255);</span>
<span class="nc" id="L88">    protected static final Color HIGHLIGHT_COLOR = Color.RED;</span>
<span class="nc" id="L89">    protected static final Color LABEL_COLOR = new Color(112, 146, 190);</span>
<span class="nc" id="L90">    protected static final Color TASK_BORDER_COLOR = new Color(187, 187, 187);</span>
<span class="nc" id="L91">    protected static final Color STAGE_BORDER_COLOR = new Color(0, 0, 0);</span>
<span class="nc" id="L92">    protected static final Color EVENT_BORDER_COLOR = new Color(88, 88, 88);</span>

    // Fonts
    protected static Font LABEL_FONT;
    protected static Font ANNOTATION_FONT;

    // Strokes
<span class="nc" id="L99">    protected static final Stroke THICK_TASK_BORDER_STROKE = new BasicStroke(3.0f);</span>
<span class="nc" id="L100">    protected static final Stroke GATEWAY_TYPE_STROKE = new BasicStroke(3.0f);</span>
<span class="nc" id="L101">    protected static final Stroke ASSOCIATION_STROKE = new BasicStroke(2.0f, BasicStroke.CAP_BUTT, BasicStroke.JOIN_MITER, 1.0f, new float[] { 2.0f, 2.0f }, 0.0f);</span>

    // icons
    protected static final int ICON_PADDING = 5;
    protected static BufferedImage TIMER_IMAGE;
    protected static BufferedImage USERLISTENER_IMAGE;
    protected static BufferedImage VARIABLELISTENER_IMAGE;
    protected static BufferedImage USERTASK_IMAGE;
    protected static BufferedImage SERVICETASK_IMAGE;
    protected static BufferedImage CASETASK_IMAGE;
    protected static BufferedImage PROCESSTASK_IMAGE;
    protected static BufferedImage DECISIONTASK_IMAGE;
    protected static BufferedImage SENDEVENTTASK_IMAGE;

<span class="nc" id="L115">    protected int canvasWidth = -1;</span>
<span class="nc" id="L116">    protected int canvasHeight = -1;</span>
<span class="nc" id="L117">    protected int minX = -1;</span>
<span class="nc" id="L118">    protected int minY = -1;</span>
    protected BufferedImage caseDiagram;
    protected Graphics2D g;
    protected FontMetrics fontMetrics;
    protected boolean closed;
    protected ClassLoader customClassLoader;
<span class="nc" id="L124">    protected String activityFontName = &quot;Arial&quot;;</span>
<span class="nc" id="L125">    protected String labelFontName = &quot;Arial&quot;;</span>
<span class="nc" id="L126">    protected String annotationFontName = &quot;Arial&quot;;</span>

    /**
     * Creates an empty canvas with given width and height.
     *
     * Allows to specify minimal boundaries on the left and upper side of the canvas. This is useful for diagrams that have white space there. Everything beneath these minimum values will be cropped.
     * It's also possible to pass a specific font name and a class loader for the icon images.
     *
     */
    public DefaultCaseDiagramCanvas(int width, int height, int minX, int minY, String imageType,
<span class="nc" id="L136">            String activityFontName, String labelFontName, String annotationFontName, ClassLoader customClassLoader) {</span>

<span class="nc" id="L138">        this.canvasWidth = width;</span>
<span class="nc" id="L139">        this.canvasHeight = height;</span>
<span class="nc" id="L140">        this.minX = minX;</span>
<span class="nc" id="L141">        this.minY = minY;</span>
<span class="nc bnc" id="L142" title="All 2 branches missed.">        if (activityFontName != null) {</span>
<span class="nc" id="L143">            this.activityFontName = activityFontName;</span>
        }
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (labelFontName != null) {</span>
<span class="nc" id="L146">            this.labelFontName = labelFontName;</span>
        }
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (annotationFontName != null) {</span>
<span class="nc" id="L149">            this.annotationFontName = annotationFontName;</span>
        }
<span class="nc" id="L151">        this.customClassLoader = customClassLoader;</span>

<span class="nc" id="L153">        initialize(imageType);</span>
<span class="nc" id="L154">    }</span>

    /**
     * Creates an empty canvas with given width and height.
     *
     * Allows to specify minimal boundaries on the left and upper side of the canvas. This is useful for diagrams that have white space there (eg Signavio). Everything beneath these minimum values
     * will be cropped.
     *
     * @param minX
     *            Hint that will be used when generating the image. Parts that fall below minX on the horizontal scale will be cropped.
     * @param minY
     *            Hint that will be used when generating the image. Parts that fall below minX on the horizontal scale will be cropped.
     */
<span class="nc" id="L167">    public DefaultCaseDiagramCanvas(int width, int height, int minX, int minY, String imageType) {</span>
<span class="nc" id="L168">        this.canvasWidth = width;</span>
<span class="nc" id="L169">        this.canvasHeight = height;</span>
<span class="nc" id="L170">        this.minX = minX;</span>
<span class="nc" id="L171">        this.minY = minY;</span>

<span class="nc" id="L173">        initialize(imageType);</span>
<span class="nc" id="L174">    }</span>

    public void initialize(String imageType) {
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (&quot;png&quot;.equalsIgnoreCase(imageType)) {</span>
<span class="nc" id="L178">            this.caseDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_ARGB);</span>
        } else {
<span class="nc" id="L180">            this.caseDiagram = new BufferedImage(canvasWidth, canvasHeight, BufferedImage.TYPE_INT_RGB);</span>
        }

<span class="nc" id="L183">        this.g = caseDiagram.createGraphics();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">        if (!&quot;png&quot;.equalsIgnoreCase(imageType)) {</span>
<span class="nc" id="L185">            this.g.setBackground(new Color(255, 255, 255, 0));</span>
<span class="nc" id="L186">            this.g.clearRect(0, 0, canvasWidth, canvasHeight);</span>
        }

<span class="nc" id="L189">        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);</span>
<span class="nc" id="L190">        g.setPaint(Color.black);</span>

<span class="nc" id="L192">        Font font = new Font(activityFontName, Font.BOLD, FONT_SIZE);</span>
<span class="nc" id="L193">        g.setFont(font);</span>
<span class="nc" id="L194">        this.fontMetrics = g.getFontMetrics();</span>

<span class="nc" id="L196">        LABEL_FONT = new Font(labelFontName, Font.ITALIC, 10);</span>
<span class="nc" id="L197">        ANNOTATION_FONT = new Font(annotationFontName, Font.PLAIN, FONT_SIZE);</span>

        try {
<span class="nc" id="L200">            TIMER_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/timer.png&quot;, customClassLoader));</span>
<span class="nc" id="L201">            USERLISTENER_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/user.png&quot;, customClassLoader));</span>
<span class="nc" id="L202">            VARIABLELISTENER_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/variablelistener.png&quot;, customClassLoader));</span>
<span class="nc" id="L203">            USERTASK_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/userTask.png&quot;, customClassLoader));</span>
<span class="nc" id="L204">            SERVICETASK_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/serviceTask.png&quot;, customClassLoader));</span>
<span class="nc" id="L205">            CASETASK_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/caseTask.png&quot;, customClassLoader));</span>
<span class="nc" id="L206">            PROCESSTASK_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/processTask.png&quot;, customClassLoader));</span>
<span class="nc" id="L207">            DECISIONTASK_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/decisionTask.png&quot;, customClassLoader));</span>
<span class="nc" id="L208">            SENDEVENTTASK_IMAGE = ImageIO.read(ReflectUtil.getResource(&quot;org/flowable/icons/sendEventTask.png&quot;, customClassLoader));</span>

<span class="nc" id="L210">        } catch (IOException e) {</span>
<span class="nc" id="L211">            LOGGER.warn(&quot;Could not load image for case diagram creation: {}&quot;, e.getMessage());</span>
<span class="nc" id="L212">        }</span>
<span class="nc" id="L213">    }</span>

    /**
     * Generates an image of what currently is drawn on the canvas.
     *
     * Throws an {@link FlowableImageException} when {@link #close()} is already called.
     */
    public InputStream generateImage(String imageType) {
<span class="nc bnc" id="L221" title="All 2 branches missed.">        if (closed) {</span>
<span class="nc" id="L222">            throw new FlowableImageException(&quot;CaseDiagramGenerator already closed&quot;);</span>
        }

<span class="nc" id="L225">        try (ByteArrayOutputStream out = new ByteArrayOutputStream()) {</span>
<span class="nc" id="L226">            ImageIO.write(caseDiagram, imageType, out);</span>
<span class="nc" id="L227">            return new ByteArrayInputStream(out.toByteArray());</span>
<span class="nc" id="L228">        } catch (IOException e) {</span>
<span class="nc" id="L229">            throw new FlowableImageException(&quot;Error while generating case image&quot;, e);</span>
        }
    }

    /**
     * Generates an image of what currently is drawn on the canvas.
     *
     * Throws an {@link FlowableImageException} when {@link #close()} is already called.
     */
    public BufferedImage generateBufferedImage(String imageType) {
<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (closed) {</span>
<span class="nc" id="L240">            throw new FlowableImageException(&quot;CaseDiagramGenerator already closed&quot;);</span>
        }

        // Try to remove white space
<span class="nc bnc" id="L244" title="All 2 branches missed.">        minX = (minX &lt;= 5) ? 5 : minX;</span>
<span class="nc bnc" id="L245" title="All 2 branches missed.">        minY = (minY &lt;= 5) ? 5 : minY;</span>
<span class="nc" id="L246">        BufferedImage imageToSerialize = caseDiagram;</span>
<span class="nc" id="L247">        imageToSerialize = caseDiagram.getSubimage(minX - 5, minY - 5, canvasWidth - minX + 5, canvasHeight - minY + 5);</span>
<span class="nc" id="L248">        return imageToSerialize;</span>
    }

    /**
     * Closes the canvas which disallows further drawing and releases graphical resources.
     */
    public void close() {
<span class="nc" id="L255">        g.dispose();</span>
<span class="nc" id="L256">        closed = true;</span>
<span class="nc" id="L257">    }</span>

    public void drawAssociation(int[] xPoints, int[] yPoints, double scaleFactor) {
<span class="nc" id="L260">        drawConnection(xPoints, yPoints, &quot;association&quot;, scaleFactor);</span>
<span class="nc" id="L261">    }</span>

    public void drawConnection(int[] xPoints, int[] yPoints, String connectionType, double scaleFactor) {

<span class="nc" id="L265">        Paint originalPaint = g.getPaint();</span>
<span class="nc" id="L266">        Stroke originalStroke = g.getStroke();</span>

<span class="nc" id="L268">        g.setPaint(CONNECTION_COLOR);</span>
<span class="nc bnc" id="L269" title="All 2 branches missed.">        if (&quot;association&quot;.equals(connectionType)) {</span>
<span class="nc" id="L270">            g.setStroke(ASSOCIATION_STROKE);</span>
        }

<span class="nc bnc" id="L273" title="All 2 branches missed.">        for (int i = 1; i &lt; xPoints.length; i++) {</span>
<span class="nc" id="L274">            int sourceX = xPoints[i - 1];</span>
<span class="nc" id="L275">            int sourceY = yPoints[i - 1];</span>
<span class="nc" id="L276">            int targetX = xPoints[i];</span>
<span class="nc" id="L277">            int targetY = yPoints[i];</span>
<span class="nc" id="L278">            Line2D.Double line = new Line2D.Double(sourceX, sourceY, targetX, targetY);</span>
<span class="nc" id="L279">            g.draw(line);</span>
        }

<span class="nc" id="L282">        Line2D.Double line = new Line2D.Double(xPoints[xPoints.length - 2], yPoints[xPoints.length - 2], xPoints[xPoints.length - 1], yPoints[xPoints.length - 1]);</span>
<span class="nc" id="L283">        drawArrowHead(line, scaleFactor);</span>

<span class="nc" id="L285">        g.setPaint(originalPaint);</span>
<span class="nc" id="L286">        g.setStroke(originalStroke);</span>
<span class="nc" id="L287">    }</span>

    public void drawArrowHead(Line2D.Double line, double scaleFactor) {
<span class="nc" id="L290">        int doubleArrowWidth = (int) (2 * ARROW_WIDTH / scaleFactor);</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">        if (doubleArrowWidth == 0) {</span>
<span class="nc" id="L292">            doubleArrowWidth = 2;</span>
        }
<span class="nc" id="L294">        Polygon arrowHead = new Polygon();</span>
<span class="nc" id="L295">        arrowHead.addPoint(0, 0);</span>
<span class="nc" id="L296">        int arrowHeadPoint = (int) (-ARROW_WIDTH / scaleFactor);</span>
<span class="nc bnc" id="L297" title="All 2 branches missed.">        if (arrowHeadPoint == 0) {</span>
<span class="nc" id="L298">            arrowHeadPoint = -1;</span>
        }
<span class="nc" id="L300">        arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);</span>
<span class="nc" id="L301">        arrowHeadPoint = (int) (ARROW_WIDTH / scaleFactor);</span>
<span class="nc bnc" id="L302" title="All 2 branches missed.">        if (arrowHeadPoint == 0) {</span>
<span class="nc" id="L303">            arrowHeadPoint = 1;</span>
        }
<span class="nc" id="L305">        arrowHead.addPoint(arrowHeadPoint, -doubleArrowWidth);</span>

<span class="nc" id="L307">        AffineTransform transformation = new AffineTransform();</span>
<span class="nc" id="L308">        transformation.setToIdentity();</span>
<span class="nc" id="L309">        double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);</span>
<span class="nc" id="L310">        transformation.translate(line.x2, line.y2);</span>
<span class="nc" id="L311">        transformation.rotate((angle - Math.PI / 2d));</span>

<span class="nc" id="L313">        AffineTransform originalTransformation = g.getTransform();</span>
<span class="nc" id="L314">        g.setTransform(transformation);</span>
<span class="nc" id="L315">        g.fill(arrowHead);</span>
<span class="nc" id="L316">        g.setTransform(originalTransformation);</span>
<span class="nc" id="L317">    }</span>

    public void drawGenericEventListener(GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L320">        drawEventListener(graphicInfo, null, scaleFactor);</span>
<span class="nc" id="L321">    }</span>

    public void drawTimerEventListener(GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L324">        drawEventListener(graphicInfo, TIMER_IMAGE, scaleFactor);</span>
<span class="nc" id="L325">    }</span>

    public void drawUserEventListener(GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L328">        drawEventListener(graphicInfo, USERLISTENER_IMAGE, scaleFactor);</span>
<span class="nc" id="L329">    }</span>
    
    public void drawVariableEventListener(GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L332">        drawEventListener(graphicInfo, VARIABLELISTENER_IMAGE, scaleFactor);</span>
<span class="nc" id="L333">    }</span>

    public void drawEventListener(GraphicInfo graphicInfo, BufferedImage image, double scaleFactor) {
<span class="nc" id="L336">        Paint originalPaint = g.getPaint();</span>
<span class="nc" id="L337">        g.setPaint(EVENT_COLOR);</span>
<span class="nc" id="L338">        Ellipse2D circle = new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(),</span>
<span class="nc" id="L339">                graphicInfo.getWidth(), graphicInfo.getHeight());</span>
<span class="nc" id="L340">        g.fill(circle);</span>
<span class="nc" id="L341">        g.setPaint(EVENT_BORDER_COLOR);</span>
<span class="nc" id="L342">        g.draw(circle);</span>
<span class="nc" id="L343">        g.setPaint(originalPaint);</span>
<span class="nc bnc" id="L344" title="All 2 branches missed.">        if (image != null) {</span>
            // calculate coordinates to center image
<span class="nc" id="L346">            int imageX = (int) Math.round(graphicInfo.getX() + (graphicInfo.getWidth() / 2) - (image.getWidth() / (2 * scaleFactor)));</span>
<span class="nc" id="L347">            int imageY = (int) Math.round(graphicInfo.getY() + (graphicInfo.getHeight() / 2) - (image.getHeight() / (2 * scaleFactor)));</span>
<span class="nc" id="L348">            g.drawImage(image, imageX, imageY,</span>
<span class="nc" id="L349">                    (int) (image.getWidth() / scaleFactor), (int) (image.getHeight() / scaleFactor), null);</span>
        }

<span class="nc" id="L352">    }</span>

    public void drawTask(BufferedImage icon, String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L355">        drawTask(name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L356">        g.drawImage(icon, (int) (graphicInfo.getX() + ICON_PADDING / scaleFactor),</span>
<span class="nc" id="L357">                (int) (graphicInfo.getY() + ICON_PADDING / scaleFactor),</span>
<span class="nc" id="L358">                (int) (icon.getWidth() / scaleFactor), (int) (icon.getHeight() / scaleFactor), null);</span>
<span class="nc" id="L359">    }</span>

    public void drawTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L362">        drawTask(name, graphicInfo, false, scaleFactor);</span>
<span class="nc" id="L363">    }</span>

    public void drawStage(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L366">        int x = (int) graphicInfo.getX();</span>
<span class="nc" id="L367">        int y = (int) graphicInfo.getY();</span>
<span class="nc" id="L368">        int width = (int) graphicInfo.getWidth();</span>
<span class="nc" id="L369">        int height = (int) graphicInfo.getHeight();</span>
<span class="nc" id="L370">        g.drawRoundRect(x, y, width, height, 6, 6);</span>

        // Add the name as text, vertical
<span class="nc bnc" id="L373" title="All 6 branches missed.">        if (scaleFactor == 1.0 &amp;&amp; name != null &amp;&amp; name.length() &gt; 0) {</span>
            // Include some padding
<span class="nc" id="L375">            int availableTextSpace = height - 6;</span>

            // Create rotation for derived font
<span class="nc" id="L378">            AffineTransform transformation = new AffineTransform();</span>
<span class="nc" id="L379">            transformation.setToIdentity();</span>
<span class="nc" id="L380">            transformation.rotate(270 * Math.PI / 180);</span>

<span class="nc" id="L382">            Font currentFont = g.getFont();</span>
<span class="nc" id="L383">            Font theDerivedFont = currentFont.deriveFont(transformation);</span>
<span class="nc" id="L384">            g.setFont(theDerivedFont);</span>

<span class="nc" id="L386">            String truncated = fitTextToWidth(name, availableTextSpace);</span>
<span class="nc" id="L387">            int realWidth = fontMetrics.stringWidth(truncated);</span>

<span class="nc" id="L389">            g.drawString(truncated, x + 2 + fontMetrics.getHeight(), 3 + y + availableTextSpace - (availableTextSpace - realWidth) / 2);</span>
<span class="nc" id="L390">            g.setFont(currentFont);</span>
        }
<span class="nc" id="L392">    }</span>

    protected void drawTask(String name, GraphicInfo graphicInfo, boolean thickBorder, double scaleFactor) {
<span class="nc" id="L395">        Paint originalPaint = g.getPaint();</span>
<span class="nc" id="L396">        int x = (int) graphicInfo.getX();</span>
<span class="nc" id="L397">        int y = (int) graphicInfo.getY();</span>
<span class="nc" id="L398">        int width = (int) graphicInfo.getWidth();</span>
<span class="nc" id="L399">        int height = (int) graphicInfo.getHeight();</span>

        // Create a new gradient paint for every task box, gradient depends on x and y and is not relative
<span class="nc" id="L402">        g.setPaint(TASK_BOX_COLOR);</span>

<span class="nc" id="L404">        int arcR = 6;</span>
<span class="nc bnc" id="L405" title="All 2 branches missed.">        if (thickBorder) {</span>
<span class="nc" id="L406">            arcR = 3;</span>
        }

        // shape
<span class="nc" id="L410">        RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcR, arcR);</span>
<span class="nc" id="L411">        g.fill(rect);</span>
<span class="nc" id="L412">        g.setPaint(TASK_BORDER_COLOR);</span>

<span class="nc bnc" id="L414" title="All 2 branches missed.">        if (thickBorder) {</span>
<span class="nc" id="L415">            Stroke originalStroke = g.getStroke();</span>
<span class="nc" id="L416">            g.setStroke(THICK_TASK_BORDER_STROKE);</span>
<span class="nc" id="L417">            g.draw(rect);</span>
<span class="nc" id="L418">            g.setStroke(originalStroke);</span>
<span class="nc" id="L419">        } else {</span>
<span class="nc" id="L420">            g.draw(rect);</span>
        }

<span class="nc" id="L423">        g.setPaint(originalPaint);</span>
        // text
<span class="nc bnc" id="L425" title="All 6 branches missed.">        if (scaleFactor == 1.0 &amp;&amp; name != null &amp;&amp; name.length() &gt; 0) {</span>
<span class="nc" id="L426">            int boxWidth = width - (2 * TEXT_PADDING);</span>
<span class="nc" id="L427">            int boxHeight = height - 16 - ICON_PADDING - ICON_PADDING - MARKER_WIDTH - 2 - 2;</span>
<span class="nc" id="L428">            int boxX = x + width / 2 - boxWidth / 2;</span>
<span class="nc" id="L429">            int boxY = y + height / 2 - boxHeight / 2 + ICON_PADDING + ICON_PADDING - 2 - 2;</span>

<span class="nc" id="L431">            drawMultilineCentredText(name, boxX, boxY, boxWidth, boxHeight);</span>
        }
<span class="nc" id="L433">    }</span>

    protected void drawMilestone(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L436">        Paint originalPaint = g.getPaint();</span>
<span class="nc" id="L437">        int x = (int) graphicInfo.getX();</span>
<span class="nc" id="L438">        int y = (int) graphicInfo.getY();</span>
<span class="nc" id="L439">        int width = (int) graphicInfo.getWidth();</span>
<span class="nc" id="L440">        int height = (int) graphicInfo.getHeight();</span>

        // Create a new gradient paint for every task box, gradient depends on x and y and is not relative
<span class="nc" id="L443">        g.setPaint(TASK_BOX_COLOR);</span>

<span class="nc" id="L445">        int arcR = 24;</span>

        // shape
<span class="nc" id="L448">        RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, arcR, arcR);</span>
<span class="nc" id="L449">        g.fill(rect);</span>
<span class="nc" id="L450">        g.setPaint(TASK_BORDER_COLOR);</span>

<span class="nc" id="L452">        g.draw(rect);</span>

<span class="nc" id="L454">        g.setPaint(originalPaint);</span>
        // text

<span class="nc bnc" id="L457" title="All 6 branches missed.">        if (scaleFactor == 1.0 &amp;&amp; name != null &amp;&amp; name.length() &gt; 0) {</span>
<span class="nc" id="L458">            int boxWidth = width - (2 * TEXT_PADDING);</span>
<span class="nc" id="L459">            int boxHeight = height - 16 - ICON_PADDING - ICON_PADDING - MARKER_WIDTH - 2 - 2;</span>
<span class="nc" id="L460">            int boxX = x + width / 2 - boxWidth / 2;</span>
<span class="nc" id="L461">            int boxY = y + height / 2 - boxHeight / 2 + ICON_PADDING + ICON_PADDING - 2 - 2;</span>

<span class="nc" id="L463">            drawMultilineCentredText(name, boxX, boxY, boxWidth, boxHeight);</span>
        }
<span class="nc" id="L465">    }</span>

    protected void drawMultilineCentredText(String text, int x, int y, int boxWidth, int boxHeight) {
<span class="nc" id="L468">        drawMultilineText(text, x, y, boxWidth, boxHeight, true);</span>
<span class="nc" id="L469">    }</span>

    protected void drawMultilineAnnotationText(String text, int x, int y, int boxWidth, int boxHeight) {
<span class="nc" id="L472">        drawMultilineText(text, x, y, boxWidth, boxHeight, false);</span>
<span class="nc" id="L473">    }</span>

    protected void drawMultilineText(String text, int x, int y, int boxWidth, int boxHeight, boolean centered) {
        // Create an attributed string based in input text
<span class="nc" id="L477">        AttributedString attributedString = new AttributedString(text);</span>
<span class="nc" id="L478">        attributedString.addAttribute(TextAttribute.FONT, g.getFont());</span>
<span class="nc" id="L479">        attributedString.addAttribute(TextAttribute.FOREGROUND, Color.black);</span>

<span class="nc" id="L481">        AttributedCharacterIterator characterIterator = attributedString.getIterator();</span>

<span class="nc" id="L483">        int currentHeight = 0;</span>
        // Prepare a list of lines of text we'll be drawing
<span class="nc" id="L485">        List&lt;TextLayout&gt; layouts = new ArrayList&lt;&gt;();</span>
<span class="nc" id="L486">        String lastLine = null;</span>

<span class="nc" id="L488">        LineBreakMeasurer measurer = new LineBreakMeasurer(characterIterator, g.getFontRenderContext());</span>

<span class="nc" id="L490">        TextLayout layout = null;</span>
<span class="nc bnc" id="L491" title="All 4 branches missed.">        while (measurer.getPosition() &lt; characterIterator.getEndIndex() &amp;&amp; currentHeight &lt;= boxHeight) {</span>

<span class="nc" id="L493">            int previousPosition = measurer.getPosition();</span>

            // Request next layout
<span class="nc" id="L496">            layout = measurer.nextLayout(boxWidth);</span>

<span class="nc" id="L498">            int height = ((Float) (layout.getDescent() + layout.getAscent() + layout.getLeading())).intValue();</span>

<span class="nc bnc" id="L500" title="All 2 branches missed.">            if (currentHeight + height &gt; boxHeight) {</span>
                // The line we're about to add should NOT be added anymore, append three dots to previous one instead
                // to indicate more text is truncated
<span class="nc bnc" id="L503" title="All 2 branches missed.">                if (!layouts.isEmpty()) {</span>
<span class="nc" id="L504">                    layouts.remove(layouts.size() - 1);</span>

<span class="nc bnc" id="L506" title="All 2 branches missed.">                    if (lastLine.length() &gt;= 4) {</span>
<span class="nc" id="L507">                        lastLine = lastLine.substring(0, lastLine.length() - 4) + &quot;...&quot;;</span>
                    }
<span class="nc" id="L509">                    layouts.add(new TextLayout(lastLine, g.getFont(), g.getFontRenderContext()));</span>
                }
                break;
            } else {
<span class="nc" id="L513">                layouts.add(layout);</span>
<span class="nc" id="L514">                lastLine = text.substring(previousPosition, measurer.getPosition());</span>
<span class="nc" id="L515">                currentHeight += height;</span>
            }
<span class="nc" id="L517">        }</span>

<span class="nc bnc" id="L519" title="All 2 branches missed.">        int currentY = y + (centered ? ((boxHeight - currentHeight) / 2) : 0);</span>
<span class="nc" id="L520">        int currentX = 0;</span>

        // Actually draw the lines
<span class="nc bnc" id="L523" title="All 2 branches missed.">        for (TextLayout textLayout : layouts) {</span>

<span class="nc" id="L525">            currentY += textLayout.getAscent();</span>
<span class="nc bnc" id="L526" title="All 2 branches missed.">            currentX = x + (centered ? ((boxWidth - ((Double) textLayout.getBounds().getWidth()).intValue()) / 2) : 0);</span>

<span class="nc" id="L528">            textLayout.draw(g, currentX, currentY);</span>
<span class="nc" id="L529">            currentY += textLayout.getDescent() + textLayout.getLeading();</span>
<span class="nc" id="L530">        }</span>

<span class="nc" id="L532">    }</span>

    protected String fitTextToWidth(String original, int width) {
<span class="nc" id="L535">        String text = original;</span>

        // remove length for &quot;...&quot;
<span class="nc" id="L538">        int maxWidth = width - 10;</span>

<span class="nc bnc" id="L540" title="All 4 branches missed.">        while (fontMetrics.stringWidth(text + &quot;...&quot;) &gt; maxWidth &amp;&amp; text.length() &gt; 0) {</span>
<span class="nc" id="L541">            text = text.substring(0, text.length() - 1);</span>
        }

<span class="nc bnc" id="L544" title="All 2 branches missed.">        if (!text.equals(original)) {</span>
<span class="nc" id="L545">            text = text + &quot;...&quot;;</span>
        }

<span class="nc" id="L548">        return text;</span>
    }

    public void drawUserTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L552">        drawTask(USERTASK_IMAGE, name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L553">    }</span>

    public void drawServiceTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L556">        drawTask(SERVICETASK_IMAGE, name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L557">    }</span>
    
    public void drawSendEventTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L560">        drawTask(SENDEVENTTASK_IMAGE, name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L561">    }</span>

    public void drawCaseTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L564">        drawTask(CASETASK_IMAGE, name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L565">    }</span>

    public void drawProcessTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L568">        drawTask(PROCESSTASK_IMAGE, name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L569">    }</span>

    public void drawDecisionTask(String name, GraphicInfo graphicInfo, double scaleFactor) {
<span class="nc" id="L572">        drawTask(DECISIONTASK_IMAGE, name, graphicInfo, scaleFactor);</span>
<span class="nc" id="L573">    }</span>

    public void drawCriterion(GraphicInfo graphicInfo, boolean fillShape) {
<span class="nc" id="L576">        Polygon rhombus = new Polygon();</span>
<span class="nc" id="L577">        int x = (int) graphicInfo.getX();</span>
<span class="nc" id="L578">        int y = (int) graphicInfo.getY();</span>
<span class="nc" id="L579">        int width = (int) graphicInfo.getWidth();</span>
<span class="nc" id="L580">        int height = (int) graphicInfo.getHeight();</span>

<span class="nc" id="L582">        rhombus.addPoint(x, y + (height / 2));</span>
<span class="nc" id="L583">        rhombus.addPoint(x + (width / 2), y + height);</span>
<span class="nc" id="L584">        rhombus.addPoint(x + width, y + (height / 2));</span>
<span class="nc" id="L585">        rhombus.addPoint(x + (width / 2), y);</span>
<span class="nc" id="L586">        g.draw(rhombus);</span>

<span class="nc bnc" id="L588" title="All 2 branches missed.">        if (fillShape) {</span>
<span class="nc" id="L589">            g.fill(rhombus);</span>
        }
<span class="nc" id="L591">    }</span>

    public void drawEntryCriterion(GraphicInfo graphicInfo) {
<span class="nc" id="L594">        drawCriterion(graphicInfo, false);</span>
<span class="nc" id="L595">    }</span>

    public void drawExitCriterion(GraphicInfo graphicInfo) {
<span class="nc" id="L598">        Paint originalPaint = g.getPaint();</span>
        // Create a new gradient paint for every task box, gradient depends on x and y and is not relative
<span class="nc" id="L600">        g.setPaint(Color.BLACK);</span>

<span class="nc" id="L602">        drawCriterion(graphicInfo, true);</span>

<span class="nc" id="L604">        g.setPaint(originalPaint);</span>
<span class="nc" id="L605">    }</span>

    public void drawHighLight(int x, int y, int width, int height) {
<span class="nc" id="L608">        Paint originalPaint = g.getPaint();</span>
<span class="nc" id="L609">        Stroke originalStroke = g.getStroke();</span>

<span class="nc" id="L611">        g.setPaint(HIGHLIGHT_COLOR);</span>
<span class="nc" id="L612">        g.setStroke(THICK_TASK_BORDER_STROKE);</span>

<span class="nc" id="L614">        RoundRectangle2D rect = new RoundRectangle2D.Double(x, y, width, height, 20, 20);</span>
<span class="nc" id="L615">        g.draw(rect);</span>

<span class="nc" id="L617">        g.setPaint(originalPaint);</span>
<span class="nc" id="L618">        g.setStroke(originalStroke);</span>
<span class="nc" id="L619">    }</span>

    /**
     * This method makes coordinates of connection flow better.
     *
     * @param sourceShapeType
     * @param targetShapeType
     * @param sourceGraphicInfo
     * @param targetGraphicInfo
     * @param graphicInfoList
     *
     */
    public List&lt;GraphicInfo&gt; connectionPerfectionizer(SHAPE_TYPE sourceShapeType, SHAPE_TYPE targetShapeType, GraphicInfo sourceGraphicInfo, GraphicInfo targetGraphicInfo, List&lt;GraphicInfo&gt; graphicInfoList) {
<span class="nc" id="L632">        Shape shapeFirst = createShape(sourceShapeType, sourceGraphicInfo);</span>
<span class="nc" id="L633">        Shape shapeLast = createShape(targetShapeType, targetGraphicInfo);</span>
        
<span class="nc bnc" id="L635" title="All 4 branches missed.">        if (graphicInfoList != null &amp;&amp; graphicInfoList.size() &gt; 0) {</span>
<span class="nc" id="L636">            GraphicInfo graphicInfoFirst = graphicInfoList.get(0);</span>
<span class="nc" id="L637">            GraphicInfo graphicInfoLast = graphicInfoList.get(graphicInfoList.size() - 1);</span>
<span class="nc bnc" id="L638" title="All 2 branches missed.">            if (shapeFirst != null) {</span>
<span class="nc" id="L639">                graphicInfoFirst.setX(shapeFirst.getBounds2D().getCenterX());</span>
<span class="nc" id="L640">                graphicInfoFirst.setY(shapeFirst.getBounds2D().getCenterY());</span>
            }
<span class="nc bnc" id="L642" title="All 2 branches missed.">            if (shapeLast != null) {</span>
<span class="nc" id="L643">                graphicInfoLast.setX(shapeLast.getBounds2D().getCenterX());</span>
<span class="nc" id="L644">                graphicInfoLast.setY(shapeLast.getBounds2D().getCenterY());</span>
            }

<span class="nc" id="L647">            Point p = null;</span>

<span class="nc bnc" id="L649" title="All 2 branches missed.">            if (shapeFirst != null) {</span>
<span class="nc bnc" id="L650" title="All 2 branches missed.">                if (graphicInfoList.size() &gt; 1) {</span>
<span class="nc" id="L651">                    Line2D.Double lineFirst = new Line2D.Double(graphicInfoFirst.getX(), graphicInfoFirst.getY(), graphicInfoList.get(1).getX(), graphicInfoList.get(1).getY());</span>
<span class="nc" id="L652">                    p = getIntersection(shapeFirst, lineFirst);</span>
                }
<span class="nc bnc" id="L654" title="All 2 branches missed.">                if (p != null) {</span>
<span class="nc" id="L655">                    graphicInfoFirst.setX(p.getX());</span>
<span class="nc" id="L656">                    graphicInfoFirst.setY(p.getY());</span>
                }
            }

<span class="nc bnc" id="L660" title="All 2 branches missed.">            if (shapeLast != null) {</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">                if (graphicInfoList.size() &gt;= 2) {</span>
<span class="nc" id="L662">                    Line2D.Double lineLast = new Line2D.Double(graphicInfoLast.getX(), graphicInfoLast.getY(), graphicInfoList.get(graphicInfoList.size() - 2).getX(), graphicInfoList.get(graphicInfoList.size() - 2).getY());</span>
<span class="nc" id="L663">                    p = getIntersection(shapeLast, lineLast);</span>
                }
<span class="nc bnc" id="L665" title="All 2 branches missed.">                if (p != null) {</span>
<span class="nc" id="L666">                    graphicInfoLast.setX(p.getX());</span>
<span class="nc" id="L667">                    graphicInfoLast.setY(p.getY());</span>
                }
            }
        }

<span class="nc" id="L672">        return graphicInfoList;</span>
    }

    /**
     * This method creates shape by type and coordinates.
     *
     * @param shapeType
     * @param graphicInfo
     * @return Shape
     */
    private static Shape createShape(SHAPE_TYPE shapeType, GraphicInfo graphicInfo) {
<span class="nc bnc" id="L683" title="All 2 branches missed.">        if (SHAPE_TYPE.Rectangle == shapeType) {</span>
            // source is rectangle
<span class="nc" id="L685">            return new Rectangle2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());</span>
<span class="nc bnc" id="L686" title="All 2 branches missed.">        } else if (SHAPE_TYPE.Rhombus == shapeType) {</span>
            // source is rhombus
<span class="nc" id="L688">            Path2D.Double rhombus = new Path2D.Double();</span>
<span class="nc" id="L689">            rhombus.moveTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);</span>
<span class="nc" id="L690">            rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY() + graphicInfo.getHeight());</span>
<span class="nc" id="L691">            rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth(), graphicInfo.getY() + graphicInfo.getHeight() / 2);</span>
<span class="nc" id="L692">            rhombus.lineTo(graphicInfo.getX() + graphicInfo.getWidth() / 2, graphicInfo.getY());</span>
<span class="nc" id="L693">            rhombus.lineTo(graphicInfo.getX(), graphicInfo.getY() + graphicInfo.getHeight() / 2);</span>
<span class="nc" id="L694">            rhombus.closePath();</span>
<span class="nc" id="L695">            return rhombus;</span>
<span class="nc bnc" id="L696" title="All 2 branches missed.">        } else if (SHAPE_TYPE.Ellipse == shapeType) {</span>
            // source is ellipse
<span class="nc" id="L698">            return new Ellipse2D.Double(graphicInfo.getX(), graphicInfo.getY(), graphicInfo.getWidth(), graphicInfo.getHeight());</span>
        } else {
            // unknown source element, just do not correct coordinates
        }
<span class="nc" id="L702">        return null;</span>
    }

    /**
     * This method returns intersection point of shape border and line.
     *
     * @param shape
     * @param line
     * @return Point
     */
    private static Point getIntersection(Shape shape, Line2D.Double line) {
<span class="nc bnc" id="L713" title="All 2 branches missed.">        if (shape instanceof Ellipse2D) {</span>
<span class="nc" id="L714">            return getEllipseIntersection(shape, line);</span>
<span class="nc bnc" id="L715" title="All 4 branches missed.">        } else if (shape instanceof Rectangle2D || shape instanceof Path2D) {</span>
<span class="nc" id="L716">            return getShapeIntersection(shape, line);</span>
        } else {
            // something strange
<span class="nc" id="L719">            return null;</span>
        }
    }

    /**
     * This method calculates ellipse intersection with line
     *
     * @param shape
     *            Bounds of this shape used to calculate parameters of inscribed into this bounds ellipse.
     * @param line
     * @return Intersection point
     */
    private static Point getEllipseIntersection(Shape shape, Line2D.Double line) {
<span class="nc" id="L732">        double angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);</span>
<span class="nc" id="L733">        double x = shape.getBounds2D().getWidth() / 2 * Math.cos(angle) + shape.getBounds2D().getCenterX();</span>
<span class="nc" id="L734">        double y = shape.getBounds2D().getHeight() / 2 * Math.sin(angle) + shape.getBounds2D().getCenterY();</span>
<span class="nc" id="L735">        Point p = new Point();</span>
<span class="nc" id="L736">        p.setLocation(x, y);</span>
<span class="nc" id="L737">        return p;</span>
    }

    /**
     * This method calculates shape intersection with line.
     *
     * @param shape
     * @param line
     * @return Intersection point
     */
    private static Point getShapeIntersection(Shape shape, Line2D.Double line) {
<span class="nc" id="L748">        PathIterator it = shape.getPathIterator(null);</span>
<span class="nc" id="L749">        double[] coords = new double[6];</span>
<span class="nc" id="L750">        double[] pos = new double[2];</span>
<span class="nc" id="L751">        Line2D.Double l = new Line2D.Double();</span>
<span class="nc bnc" id="L752" title="All 2 branches missed.">        while (!it.isDone()) {</span>
<span class="nc" id="L753">            int type = it.currentSegment(coords);</span>
<span class="nc bnc" id="L754" title="All 4 branches missed.">            switch (type) {</span>
            case PathIterator.SEG_MOVETO:
<span class="nc" id="L756">                pos[0] = coords[0];</span>
<span class="nc" id="L757">                pos[1] = coords[1];</span>
<span class="nc" id="L758">                break;</span>
            case PathIterator.SEG_LINETO:
<span class="nc" id="L760">                l = new Line2D.Double(pos[0], pos[1], coords[0], coords[1]);</span>
<span class="nc bnc" id="L761" title="All 2 branches missed.">                if (line.intersectsLine(l)) {</span>
<span class="nc" id="L762">                    return getLinesIntersection(line, l);</span>
                }
<span class="nc" id="L764">                pos[0] = coords[0];</span>
<span class="nc" id="L765">                pos[1] = coords[1];</span>
<span class="nc" id="L766">                break;</span>
            case PathIterator.SEG_CLOSE:
<span class="nc" id="L768">                break;</span>
            default:
                // whatever
            }
<span class="nc" id="L772">            it.next();</span>
<span class="nc" id="L773">        }</span>
<span class="nc" id="L774">        return null;</span>
    }

    /**
     * This method calculates intersections of two lines.
     *
     * @param a
     *            Line 1
     * @param b
     *            Line 2
     * @return Intersection point
     */
    private static Point getLinesIntersection(Line2D a, Line2D b) {
<span class="nc" id="L787">        double d = (a.getX1() - a.getX2()) * (b.getY2() - b.getY1()) - (a.getY1() - a.getY2()) * (b.getX2() - b.getX1());</span>
<span class="nc" id="L788">        double da = (a.getX1() - b.getX1()) * (b.getY2() - b.getY1()) - (a.getY1() - b.getY1()) * (b.getX2() - b.getX1());</span>
<span class="nc" id="L789">        double ta = da / d;</span>

<span class="nc" id="L791">        Point p = new Point();</span>
<span class="nc" id="L792">        p.setLocation(a.getX1() + ta * (a.getX2() - a.getX1()), a.getY1() + ta * (a.getY2() - a.getY1()));</span>
<span class="nc" id="L793">        return p;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>