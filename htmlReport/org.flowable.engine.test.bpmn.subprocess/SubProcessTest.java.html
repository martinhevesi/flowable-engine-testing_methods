<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SubProcessTest.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">org.flowable.engine.test.bpmn.subprocess</a> &gt; <span class="el_source">SubProcessTest.java</span></div><h1>SubProcessTest.java</h1><pre class="source lang-java linenums">/* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.flowable.engine.test.bpmn.subprocess;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.entry;
import static org.assertj.core.api.Assertions.tuple;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Map;

import org.flowable.common.engine.impl.history.HistoryLevel;
import org.flowable.common.engine.impl.util.CollectionUtil;
import org.flowable.engine.history.HistoricActivityInstance;
import org.flowable.engine.impl.test.HistoryTestHelper;
import org.flowable.engine.impl.test.PluggableFlowableTestCase;
import org.flowable.engine.runtime.ActivityInstance;
import org.flowable.engine.runtime.ProcessInstance;
import org.flowable.engine.test.Deployment;
import org.flowable.job.api.Job;
import org.flowable.task.api.Task;
import org.flowable.task.api.TaskQuery;
import org.flowable.task.api.history.HistoricTaskInstance;
import org.junit.jupiter.api.Test;

/**
 * @author Joram Barrez
 * @author Tijs Rademakers
 */
<span class="nc" id="L45">public class SubProcessTest extends PluggableFlowableTestCase {</span>

    @Test
    @Deployment
    public void testSimpleSubProcess() {

        // After staring the process, the task in the subprocess should be active
<span class="nc" id="L52">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;simpleSubProcess&quot;);</span>
<span class="nc" id="L53">        org.flowable.task.api.Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L54">        assertThat(subProcessTask.getName()).isEqualTo(&quot;Task in subprocess&quot;);</span>

<span class="nc" id="L56">        assertThat(runtimeService.createActivityInstanceQuery().list())</span>
<span class="nc" id="L57">            .extracting(ActivityInstance::getActivityType, ActivityInstance::getActivityId)</span>
<span class="nc" id="L58">            .containsExactlyInAnyOrder(</span>
<span class="nc" id="L59">                tuple(&quot;startEvent&quot;, &quot;theStart&quot;),</span>
<span class="nc" id="L60">                tuple(&quot;sequenceFlow&quot;, &quot;flow1&quot;),</span>
<span class="nc" id="L61">                tuple(&quot;subProcess&quot;, &quot;subProcess&quot;),</span>
<span class="nc" id="L62">                tuple(&quot;startEvent&quot;, &quot;subProcessStart&quot;),</span>
<span class="nc" id="L63">                tuple(&quot;sequenceFlow&quot;, &quot;flow2&quot;),</span>
<span class="nc" id="L64">                tuple(&quot;userTask&quot;, &quot;subProcessTask&quot;)</span>
            );

        // After completing the task in the subprocess,
        // the subprocess scope is destroyed and the complete process ends
<span class="nc" id="L69">        taskService.complete(subProcessTask.getId());</span>
<span class="nc" id="L70">        assertThat(runtimeService.createProcessInstanceQuery().processInstanceId(pi.getId()).singleResult()).isNull();</span>
<span class="nc" id="L71">    }</span>

    /**
     * Same test case as before, but now with all automatic steps
     */
    @Test
    @Deployment
    public void testSimpleAutomaticSubProcess() {
<span class="nc" id="L79">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;simpleSubProcessAutomatic&quot;);</span>
<span class="nc" id="L80">        assertThat(pi.isEnded()).isTrue();</span>
<span class="nc" id="L81">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L82">    }</span>

    @Test
    @Deployment
    public void testSimpleSubProcessWithTimer() {

        // We need to make sure the time ends on .000, .003 or .007 due to SQL Server rounding to that
<span class="nc" id="L89">        Date startTime = Date.from(Instant.now().truncatedTo(ChronoUnit.SECONDS).plusMillis(677));</span>

        // After staring the process, the task in the subprocess should be active
<span class="nc" id="L92">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;simpleSubProcess&quot;);</span>
<span class="nc" id="L93">        org.flowable.task.api.Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L94">        assertThat(subProcessTask.getName()).isEqualTo(&quot;Task in subprocess&quot;);</span>

        // Setting the clock forward 2 hours 1 second (timer fires in 2 hours) and fire up the job executor
<span class="nc" id="L97">        processEngineConfiguration.getClock().setCurrentTime(new Date(startTime.getTime() + (2 * 60 * 60 * 1000) + 1000));</span>
<span class="nc" id="L98">        assertThat(managementService.createTimerJobQuery().count()).isEqualTo(1);</span>
<span class="nc" id="L99">        waitForJobExecutorToProcessAllJobs(7000L, 500L);</span>

        // The subprocess should be left, and the escalated task should be active
<span class="nc" id="L102">        org.flowable.task.api.Task escalationTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L103">        assertThat(escalationTask.getName()).isEqualTo(&quot;Fix escalated problem&quot;);</span>

        // Verify history for task that was killed
<span class="nc bnc" id="L106" title="All 2 branches missed.">        if (HistoryTestHelper.isHistoryLevelAtLeast(HistoryLevel.ACTIVITY, processEngineConfiguration)) {</span>
<span class="nc" id="L107">            HistoricTaskInstance historicTaskInstance = historyService.createHistoricTaskInstanceQuery().taskName(&quot;Task in subprocess&quot;).singleResult();</span>
<span class="nc" id="L108">            assertThat(historicTaskInstance.getEndTime()).isNotNull();</span>

<span class="nc" id="L110">            HistoricActivityInstance historicActivityInstance = historyService.createHistoricActivityInstanceQuery().activityId(&quot;subProcessTask&quot;).singleResult();</span>
<span class="nc" id="L111">            assertActivityInstancesAreSame(historicActivityInstance, runtimeService.createActivityInstanceQuery().activityInstanceId(historicActivityInstance.getId()).singleResult());</span>
<span class="nc" id="L112">            assertThat(historicActivityInstance.getEndTime()).isNotNull();</span>
        }
<span class="nc" id="L114">    }</span>

    /**
     * A test case that has a timer attached to the subprocess, where 2 concurrent paths are defined when the timer fires.
     */
    @Deployment
    public void IGNORE_testSimpleSubProcessWithConcurrentTimer() {

        // After staring the process, the task in the subprocess should be active
<span class="nc" id="L123">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;simpleSubProcessWithConcurrentTimer&quot;);</span>
<span class="nc" id="L124">        TaskQuery taskQuery = taskService.createTaskQuery().processInstanceId(pi.getId()).orderByTaskName().asc();</span>

<span class="nc" id="L126">        org.flowable.task.api.Task subProcessTask = taskQuery.singleResult();</span>
<span class="nc" id="L127">        assertThat(subProcessTask.getName()).isEqualTo(&quot;Task in subprocess&quot;);</span>

        // When the timer is fired (after 2 hours), two concurrent paths should be created
<span class="nc" id="L130">        Job job = managementService.createJobQuery().singleResult();</span>
<span class="nc" id="L131">        managementService.executeJob(job.getId());</span>

<span class="nc" id="L133">        List&lt;org.flowable.task.api.Task&gt; tasksAfterTimer = taskQuery.list();</span>
<span class="nc" id="L134">        assertThat(tasksAfterTimer).hasSize(2);</span>
<span class="nc" id="L135">        org.flowable.task.api.Task taskAfterTimer1 = tasksAfterTimer.get(0);</span>
<span class="nc" id="L136">        org.flowable.task.api.Task taskAfterTimer2 = tasksAfterTimer.get(1);</span>
<span class="nc" id="L137">        assertThat(taskAfterTimer1.getName()).isEqualTo(&quot;Task after timer 1&quot;);</span>
<span class="nc" id="L138">        assertThat(taskAfterTimer2.getName()).isEqualTo(&quot;Task after timer 2&quot;);</span>

        // Completing the two tasks should end the process instance
<span class="nc" id="L141">        taskService.complete(taskAfterTimer1.getId());</span>
<span class="nc" id="L142">        taskService.complete(taskAfterTimer2.getId());</span>
<span class="nc" id="L143">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L144">    }</span>

    /**
     * Test case where the simple sub process of previous test cases is nested within another subprocess.
     */
    @Test
    @Deployment
    public void testNestedSimpleSubProcess() {

        // Start and delete a process with a nested subprocess when it is not yet ended
<span class="nc" id="L154">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;nestedSimpleSubProcess&quot;, CollectionUtil.singletonMap(&quot;someVar&quot;, &quot;abc&quot;));</span>
<span class="nc" id="L155">        runtimeService.deleteProcessInstance(pi.getId(), &quot;deleted&quot;);</span>

        // After staring the process, the task in the inner subprocess must be active
<span class="nc" id="L158">        pi = runtimeService.startProcessInstanceByKey(&quot;nestedSimpleSubProcess&quot;);</span>
<span class="nc" id="L159">        org.flowable.task.api.Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L160">        assertThat(subProcessTask.getName()).isEqualTo(&quot;Task in subprocess&quot;);</span>

        // After completing the task in the subprocess,
        // both subprocesses are destroyed and the task after the subprocess should be active
<span class="nc" id="L164">        taskService.complete(subProcessTask.getId());</span>
<span class="nc" id="L165">        org.flowable.task.api.Task taskAfterSubProcesses = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L166">        assertThat(taskAfterSubProcesses).isNotNull();</span>
<span class="nc" id="L167">        assertThat(taskAfterSubProcesses.getName()).isEqualTo(&quot;Task after subprocesses&quot;);</span>
<span class="nc" id="L168">        taskService.complete(taskAfterSubProcesses.getId());</span>

<span class="nc" id="L170">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L171">    }</span>

    @Test
    @Deployment
    public void testNestedSimpleSubprocessWithTimerOnInnerSubProcess() {
        // We need to make sure the time ends on .000, .003 or .007 due to SQL Server rounding to that
<span class="nc" id="L177">        Date startTime = Date.from(Instant.now().truncatedTo(ChronoUnit.SECONDS).plusMillis(370));</span>

        // After staring the process, the task in the subprocess should be active
<span class="nc" id="L180">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;nestedSubProcessWithTimer&quot;);</span>
<span class="nc" id="L181">        org.flowable.task.api.Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L182">        assertThat(subProcessTask.getName()).isEqualTo(&quot;Task in subprocess&quot;);</span>

        // Setting the clock forward 1 hour 5 second (timer fires in 1 hour) and
        // fire up the job executor
<span class="nc" id="L186">        processEngineConfiguration.getClock().setCurrentTime(new Date(startTime.getTime() + (60 * 60 * 1000) + 5000));</span>
<span class="nc" id="L187">        waitForJobExecutorToProcessAllJobs(7000L, 50L);</span>

        // The inner subprocess should be destroyed, and the escalated task should be active
<span class="nc" id="L190">        org.flowable.task.api.Task escalationTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L191">        assertThat(escalationTask.getName()).isEqualTo(&quot;Escalated task&quot;);</span>

        // Completing the escalated task, destroys the outer scope and activates
        // the task after the subprocess
<span class="nc" id="L195">        taskService.complete(escalationTask.getId());</span>
<span class="nc" id="L196">        org.flowable.task.api.Task taskAfterSubProcess = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L197">        assertThat(taskAfterSubProcess.getName()).isEqualTo(&quot;Task after subprocesses&quot;);</span>
<span class="nc" id="L198">    }</span>

    /**
     * Test case where the simple sub process of previous test cases is nested within two other sub processes
     */
    @Test
    @Deployment
    public void testDoubleNestedSimpleSubProcess() {
        // After staring the process, the task in the inner subprocess must be active
<span class="nc" id="L207">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;nestedSimpleSubProcess&quot;);</span>
<span class="nc" id="L208">        org.flowable.task.api.Task subProcessTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L209">        assertThat(subProcessTask.getName()).isEqualTo(&quot;Task in subprocess&quot;);</span>

        // After completing the task in the subprocess,
        // both subprocesses are destroyed and the task after the subprocess
        // should be active
<span class="nc" id="L214">        taskService.complete(subProcessTask.getId());</span>
<span class="nc" id="L215">        org.flowable.task.api.Task taskAfterSubProcesses = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L216">        assertThat(taskAfterSubProcesses.getName()).isEqualTo(&quot;Task after subprocesses&quot;);</span>
<span class="nc" id="L217">    }</span>

    @Test
    @Deployment
    public void testSimpleParallelSubProcess() {

        // After starting the process, the two task in the subprocess should be active
<span class="nc" id="L224">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;simpleParallelSubProcess&quot;);</span>
<span class="nc" id="L225">        List&lt;org.flowable.task.api.Task&gt; subProcessTasks = taskService.createTaskQuery().processInstanceId(pi.getId()).orderByTaskName().asc().list();</span>

        // Tasks are ordered by name (see query)
<span class="nc" id="L228">        org.flowable.task.api.Task taskA = subProcessTasks.get(0);</span>
<span class="nc" id="L229">        org.flowable.task.api.Task taskB = subProcessTasks.get(1);</span>
<span class="nc" id="L230">        assertThat(taskA.getName()).isEqualTo(&quot;Task A&quot;);</span>
<span class="nc" id="L231">        assertThat(taskB.getName()).isEqualTo(&quot;Task B&quot;);</span>

        // Completing both tasks, should destroy the subprocess and activate the
        // task after the subprocess
<span class="nc" id="L235">        taskService.complete(taskA.getId());</span>
<span class="nc" id="L236">        taskService.complete(taskB.getId());</span>
<span class="nc" id="L237">        org.flowable.task.api.Task taskAfterSubProcess = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L238">        assertThat(taskAfterSubProcess.getName()).isEqualTo(&quot;Task after sub process&quot;);</span>
<span class="nc" id="L239">    }</span>

    @Test
    @Deployment
    public void testSimpleParallelSubProcessWithTimer() {

        // After staring the process, the tasks in the subprocess should be active
<span class="nc" id="L246">        ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(&quot;simpleParallelSubProcessWithTimer&quot;);</span>
<span class="nc" id="L247">        List&lt;org.flowable.task.api.Task&gt; subProcessTasks = taskService.createTaskQuery().processInstanceId(processInstance.getId()).orderByTaskName().asc().list();</span>

        // Tasks are ordered by name (see query)
<span class="nc" id="L250">        org.flowable.task.api.Task taskA = subProcessTasks.get(0);</span>
<span class="nc" id="L251">        org.flowable.task.api.Task taskB = subProcessTasks.get(1);</span>
<span class="nc" id="L252">        assertThat(taskA.getName()).isEqualTo(&quot;Task A&quot;);</span>
<span class="nc" id="L253">        assertThat(taskB.getName()).isEqualTo(&quot;Task B&quot;);</span>

<span class="nc" id="L255">        Job job = managementService.createTimerJobQuery().processInstanceId(processInstance.getId()).singleResult();</span>

<span class="nc" id="L257">        managementService.moveTimerToExecutableJob(job.getId());</span>
<span class="nc" id="L258">        managementService.executeJob(job.getId());</span>

        // The inner subprocess should be destroyed, and the task after the timer should be active
<span class="nc" id="L261">        org.flowable.task.api.Task taskAfterTimer = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L262">        assertThat(taskAfterTimer.getName()).isEqualTo(&quot;Task after timer&quot;);</span>

        // Completing the task after the timer ends the process instance
<span class="nc" id="L265">        taskService.complete(taskAfterTimer.getId());</span>

<span class="nc" id="L267">        assertProcessEnded(processInstance.getId());</span>
<span class="nc" id="L268">    }</span>

    @Test
    @Deployment
    public void testTwoSubProcessInParallel() {
<span class="nc" id="L273">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;twoSubProcessInParallel&quot;);</span>
<span class="nc" id="L274">        TaskQuery taskQuery = taskService.createTaskQuery().processInstanceId(pi.getId()).orderByTaskName().asc();</span>
<span class="nc" id="L275">        List&lt;org.flowable.task.api.Task&gt; tasks = taskQuery.list();</span>

        // After process start, both tasks in the subprocesses should be active
<span class="nc" id="L278">        assertThat(tasks.get(0).getName()).isEqualTo(&quot;Task in subprocess A&quot;);</span>
<span class="nc" id="L279">        assertThat(tasks.get(1).getName()).isEqualTo(&quot;Task in subprocess B&quot;);</span>

        // Completing both tasks should active the tasks outside the
        // subprocesses
<span class="nc" id="L283">        taskService.complete(tasks.get(0).getId());</span>

<span class="nc" id="L285">        tasks = taskQuery.list();</span>
<span class="nc" id="L286">        assertThat(tasks.get(0).getName()).isEqualTo(&quot;Task after subprocess A&quot;);</span>
<span class="nc" id="L287">        assertThat(tasks.get(1).getName()).isEqualTo(&quot;Task in subprocess B&quot;);</span>

<span class="nc" id="L289">        taskService.complete(tasks.get(1).getId());</span>

<span class="nc" id="L291">        tasks = taskQuery.list();</span>

<span class="nc" id="L293">        assertThat(tasks.get(0).getName()).isEqualTo(&quot;Task after subprocess A&quot;);</span>
<span class="nc" id="L294">        assertThat(tasks.get(1).getName()).isEqualTo(&quot;Task after subprocess B&quot;);</span>

        // Completing these tasks should end the process
<span class="nc" id="L297">        taskService.complete(tasks.get(0).getId());</span>
<span class="nc" id="L298">        taskService.complete(tasks.get(1).getId());</span>

<span class="nc" id="L300">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L301">    }</span>

    @Test
    @Deployment
    public void testTwoSubProcessInParallelWithinSubProcess() {
<span class="nc" id="L306">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;twoSubProcessInParallelWithinSubProcess&quot;);</span>
<span class="nc" id="L307">        TaskQuery taskQuery = taskService.createTaskQuery().processInstanceId(pi.getId()).orderByTaskName().asc();</span>
<span class="nc" id="L308">        List&lt;org.flowable.task.api.Task&gt; tasks = taskQuery.list();</span>

        // After process start, both tasks in the subprocesses should be active
<span class="nc" id="L311">        org.flowable.task.api.Task taskA = tasks.get(0);</span>
<span class="nc" id="L312">        org.flowable.task.api.Task taskB = tasks.get(1);</span>
<span class="nc" id="L313">        assertThat(taskA.getName()).isEqualTo(&quot;Task in subprocess A&quot;);</span>
<span class="nc" id="L314">        assertThat(taskB.getName()).isEqualTo(&quot;Task in subprocess B&quot;);</span>

        // Completing both tasks should active the tasks outside the subprocesses
<span class="nc" id="L317">        taskService.complete(taskA.getId());</span>
<span class="nc" id="L318">        taskService.complete(taskB.getId());</span>

<span class="nc" id="L320">        org.flowable.task.api.Task taskAfterSubProcess = taskQuery.singleResult();</span>
<span class="nc" id="L321">        assertThat(taskAfterSubProcess.getName()).isEqualTo(&quot;Task after subprocess&quot;);</span>

        // Completing this task should end the process
<span class="nc" id="L324">        taskService.complete(taskAfterSubProcess.getId());</span>
<span class="nc" id="L325">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L326">    }</span>

    @Test
    @Deployment
    public void testTwoNestedSubProcessesInParallelWithTimer() {

        // Date startTime = new Date();

<span class="nc" id="L334">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;nestedParallelSubProcessesWithTimer&quot;);</span>
<span class="nc" id="L335">        TaskQuery taskQuery = taskService.createTaskQuery().processInstanceId(pi.getId()).orderByTaskName().asc();</span>
<span class="nc" id="L336">        List&lt;org.flowable.task.api.Task&gt; tasks = taskQuery.list();</span>

        // After process start, both tasks in the subprocesses should be active
<span class="nc" id="L339">        assertThat(tasks)</span>
<span class="nc" id="L340">                .extracting(Task::getName)</span>
<span class="nc" id="L341">                .containsExactly(&quot;Task in subprocess A&quot;, &quot;Task in subprocess B&quot;);</span>

        // Firing the timer should destroy all three subprocesses and activate the task after the timer
        // processEngineConfiguration.getClock().setCurrentTime(new
        // Date(startTime.getTime() + (2 * 60 * 60 * 1000 ) + 1000));
        // waitForJobExecutorToProcessAllJobs(7000L, 50L);
<span class="nc" id="L347">        Job job = managementService.createTimerJobQuery().singleResult();</span>
<span class="nc" id="L348">        managementService.moveTimerToExecutableJob(job.getId());</span>
<span class="nc" id="L349">        managementService.executeJob(job.getId());</span>

<span class="nc" id="L351">        org.flowable.task.api.Task taskAfterTimer = taskQuery.singleResult();</span>
<span class="nc" id="L352">        assertThat(taskAfterTimer.getName()).isEqualTo(&quot;Task after timer&quot;);</span>

        // Completing the task should end the process instance
<span class="nc" id="L355">        taskService.complete(taskAfterTimer.getId());</span>
<span class="nc" id="L356">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L357">    }</span>

    /**
     * @see &lt;a href=&quot;https://activiti.atlassian.net/browse/ACT-1072&quot;&gt;https://activiti.atlassian.net/browse/ACT-1072&lt;/a&gt;
     */
    @Test
    @Deployment
    public void testNestedSimpleSubProcessWithoutEndEvent() {
<span class="nc" id="L365">        testNestedSimpleSubProcess();</span>
<span class="nc" id="L366">    }</span>

    /**
     * @see &lt;a href=&quot;https://activiti.atlassian.net/browse/ACT-1072&quot;&gt;https://activiti.atlassian.net/browse/ACT-1072&lt;/a&gt;
     */
    @Test
    @Deployment
    public void testSimpleSubProcessWithoutEndEvent() {
<span class="nc" id="L374">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;testSimpleSubProcessWithoutEndEvent&quot;);</span>
<span class="nc" id="L375">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L376">    }</span>

    /**
     * @see &lt;a href=&quot;https://activiti.atlassian.net/browse/ACT-1072&quot;&gt;https://activiti.atlassian.net/browse/ACT-1072&lt;/a&gt;
     */
    @Test
    @Deployment
    public void testNestedSubProcessesWithoutEndEvents() {
<span class="nc" id="L384">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;testNestedSubProcessesWithoutEndEvents&quot;);</span>
<span class="nc" id="L385">        assertProcessEnded(pi.getId());</span>
<span class="nc" id="L386">    }</span>

    /**
     * @see &lt;a href=&quot;https://activiti.atlassian.net/browse/ACT-1847&quot;&gt;https://activiti.atlassian.net/browse/ACT-1847&lt;/a&gt;
     */
    @Test
    @Deployment
    public void testDataObjectScope() {

        // After staring the process, the task in the subprocess should be
        // active
<span class="nc" id="L397">        ProcessInstance pi = runtimeService.startProcessInstanceByKey(&quot;dataObjectScope&quot;);</span>

        // get main process task
<span class="nc" id="L400">        org.flowable.task.api.Task currentTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>

<span class="nc" id="L402">        assertThat(currentTask.getName()).isEqualTo(&quot;Complete Task A&quot;);</span>

        // verify main process scoped variables
<span class="nc" id="L405">        Map&lt;String, Object&gt; variables = runtimeService.getVariables(pi.getId());</span>
<span class="nc" id="L406">        assertThat(variables)</span>
<span class="nc" id="L407">                .containsOnly(</span>
<span class="nc" id="L408">                        entry(&quot;StringTest123&quot;, &quot;Testing123&quot;),</span>
<span class="nc" id="L409">                        entry(&quot;NoData123&quot;, null)</span>
                );

        // After completing the task in the main process, the subprocess scope
        // initiates
<span class="nc" id="L414">        taskService.complete(currentTask.getId());</span>

        // get subprocess task
<span class="nc" id="L417">        currentTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>

<span class="nc" id="L419">        assertThat(currentTask.getName()).isEqualTo(&quot;Complete SubTask&quot;);</span>

        // verify current scoped variables - includes subprocess variables
<span class="nc" id="L422">        variables = runtimeService.getVariables(currentTask.getExecutionId());</span>
<span class="nc" id="L423">        assertThat(variables)</span>
<span class="nc" id="L424">                .containsOnly(</span>
<span class="nc" id="L425">                        entry(&quot;StringTest123&quot;, &quot;Testing123&quot;),</span>
<span class="nc" id="L426">                        entry(&quot;StringTest456&quot;, &quot;Testing456&quot;),</span>
<span class="nc" id="L427">                        entry(&quot;NoData123&quot;, null)</span>
                );

        // After completing the task in the subprocess, the subprocess scope is destroyed and the main process continues
<span class="nc" id="L431">        taskService.complete(currentTask.getId());</span>

        // verify main process scoped variables
<span class="nc" id="L434">        variables = runtimeService.getVariables(pi.getId());</span>
<span class="nc" id="L435">        assertThat(variables)</span>
<span class="nc" id="L436">                .containsOnly(</span>
<span class="nc" id="L437">                        entry(&quot;StringTest123&quot;, &quot;Testing123&quot;),</span>
<span class="nc" id="L438">                        entry(&quot;NoData123&quot;, null)</span>
                );

<span class="nc" id="L441">        currentTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
        // Verify there are no local variables assigned to the current task. (subprocess variables are gone).
<span class="nc" id="L443">        variables = runtimeService.getVariablesLocal(currentTask.getExecutionId());</span>
<span class="nc" id="L444">        assertThat(variables).isEmpty();</span>

        // After completing the final task in the main process,
        // the process scope is destroyed and the process ends
<span class="nc" id="L448">        currentTask = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();</span>
<span class="nc" id="L449">        assertThat(currentTask.getName()).isEqualTo(&quot;Complete Task B&quot;);</span>

<span class="nc" id="L451">        taskService.complete(currentTask.getId());</span>
<span class="nc" id="L452">        assertThat(runtimeService.createProcessInstanceQuery().processInstanceId(pi.getId()).singleResult()).isNull();</span>
<span class="nc" id="L453">    }</span>

    @Test
    @Deployment
    public void testAsyncMiSequentialSubProcess() {
<span class="nc" id="L458">        ProcessInstance processInstance = runtimeService.createProcessInstanceBuilder()</span>
<span class="nc" id="L459">                .processDefinitionKey(&quot;testAsyncMiSubProcess&quot;)</span>
<span class="nc" id="L460">                .variable(&quot;myList&quot;, Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;))</span>
<span class="nc" id="L461">                .start();</span>
<span class="nc" id="L462">        assertThat(taskService.createTaskQuery().processInstanceId(processInstance.getId()).count()).isZero();</span>

<span class="nc" id="L464">        Job job = managementService.createJobQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L465">        assertThat(job).isNotNull();</span>
<span class="nc" id="L466">        managementService.executeJob(job.getId());</span>

<span class="nc" id="L468">        assertThat(taskService.createTaskQuery().processInstanceId(processInstance.getId()).count()).isEqualTo(1);</span>
<span class="nc" id="L469">        Task task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L470">        String variable = (String) runtimeService.getVariable(task.getExecutionId(), &quot;counter&quot;);</span>
<span class="nc" id="L471">        assertThat(variable).isEqualTo(&quot;one&quot;);</span>
<span class="nc" id="L472">        taskService.complete(task.getId());</span>

<span class="nc" id="L474">        Job secondJob = managementService.createJobQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L475">        assertThat(secondJob.getId()).isNotSameAs(job.getId());</span>
<span class="nc" id="L476">        managementService.executeJob(secondJob.getId());</span>

<span class="nc" id="L478">        task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L479">        assertThat((String) runtimeService.getVariable(task.getExecutionId(), &quot;counter&quot;)).isEqualTo(&quot;two&quot;);</span>
<span class="nc" id="L480">        taskService.complete(task.getId());</span>

<span class="nc" id="L482">        Job thirdJob = managementService.createJobQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L483">        assertThat(thirdJob.getId()).isNotSameAs(secondJob.getId());</span>
<span class="nc" id="L484">        managementService.executeJob(thirdJob.getId());</span>

<span class="nc" id="L486">        task = taskService.createTaskQuery().processInstanceId(processInstance.getId()).singleResult();</span>
<span class="nc" id="L487">        assertThat((String) runtimeService.getVariable(task.getExecutionId(), &quot;counter&quot;)).isEqualTo(&quot;three&quot;);</span>
<span class="nc" id="L488">        taskService.complete(task.getId());</span>

<span class="nc" id="L490">        assertProcessEnded(processInstance.getId());</span>
<span class="nc" id="L491">    }</span>

    @Test
    @Deployment
    public void testAsyncMiParallelSubProcess() {
<span class="nc" id="L496">        ProcessInstance processInstance = runtimeService.createProcessInstanceBuilder()</span>
<span class="nc" id="L497">                .processDefinitionKey(&quot;testAsyncMiSubProcess&quot;)</span>
<span class="nc" id="L498">                .variable(&quot;myList&quot;, Arrays.asList(&quot;one&quot;, &quot;two&quot;, &quot;three&quot;))</span>
<span class="nc" id="L499">                .start();</span>
<span class="nc" id="L500">        assertThat(taskService.createTaskQuery().processInstanceId(processInstance.getId()).count()).isZero();</span>

<span class="nc" id="L502">        List&lt;Job&gt; jobs = managementService.createJobQuery().processInstanceId(processInstance.getId()).list();</span>
<span class="nc" id="L503">        assertThat(jobs).hasSize(3);</span>
<span class="nc" id="L504">        jobs.forEach(job -&gt; managementService.executeJob(job.getId()));</span>

<span class="nc" id="L506">        assertThat(taskService.createTaskQuery().processInstanceId(processInstance.getId()).count()).isEqualTo(3);</span>
<span class="nc" id="L507">        taskService.createTaskQuery().processInstanceId(processInstance.getId()).list().forEach(task -&gt; taskService.complete(task.getId()));</span>

<span class="nc" id="L509">        assertProcessEnded(processInstance.getId());</span>
<span class="nc" id="L510">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>