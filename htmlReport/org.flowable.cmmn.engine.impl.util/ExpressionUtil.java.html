<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ExpressionUtil.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">org.flowable.cmmn.engine.impl.util</a> &gt; <span class="el_source">ExpressionUtil.java</span></div><h1>ExpressionUtil.java</h1><pre class="source lang-java linenums">/* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.flowable.cmmn.engine.impl.util;

import java.util.Collections;
import java.util.List;
import java.util.stream.Collectors;

import org.apache.commons.lang3.StringUtils;
import org.flowable.cmmn.api.runtime.PlanItemInstance;
import org.flowable.cmmn.api.runtime.PlanItemInstanceState;
import org.flowable.cmmn.engine.impl.persistence.entity.PlanItemInstanceContainer;
import org.flowable.cmmn.engine.impl.persistence.entity.PlanItemInstanceEntity;
import org.flowable.cmmn.model.Criterion;
import org.flowable.cmmn.model.PlanItem;
import org.flowable.cmmn.model.PlanItemControl;
import org.flowable.cmmn.model.RepetitionRule;
import org.flowable.cmmn.model.Stage;
import org.flowable.common.engine.api.FlowableException;
import org.flowable.common.engine.api.FlowableIllegalArgumentException;
import org.flowable.common.engine.api.delegate.Expression;
import org.flowable.common.engine.api.variable.VariableContainer;
import org.flowable.common.engine.impl.interceptor.CommandContext;

/**
 * @author Joram Barrez
 * @author Micha Kiener
 */
<span class="nc" id="L39">public class ExpressionUtil {</span>

    public static boolean evaluateBooleanExpression(CommandContext commandContext, VariableContainer variableContainer, String condition) {
<span class="nc" id="L42">        Object evaluationResult = evaluateExpression(commandContext, variableContainer, condition);</span>
<span class="nc bnc" id="L43" title="All 2 branches missed.">        if (evaluationResult instanceof Boolean) {</span>
<span class="nc" id="L44">            return (boolean) evaluationResult;</span>
<span class="nc bnc" id="L45" title="All 2 branches missed.">        } else if (evaluationResult instanceof String) {</span>
<span class="nc" id="L46">            return &quot;true&quot;.equals(((String) evaluationResult).toLowerCase());</span>
        } else {
<span class="nc" id="L48">            throw new FlowableException(&quot;Expression condition &quot; + condition + &quot; did not evaluate to a boolean value with &quot; + variableContainer);</span>
        }
    }

    public static Object evaluateExpression(CommandContext commandContext, VariableContainer variableContainer, String expression) {
<span class="nc" id="L53">        Expression exp = CommandContextUtil.getExpressionManager(commandContext).createExpression(expression);</span>
<span class="nc" id="L54">        return exp.getValue(variableContainer);</span>
    }

    public static boolean isRequiredPlanItemInstance(CommandContext commandContext, PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc" id="L58">        PlanItemControl planItemControl = planItemInstanceEntity.getPlanItem().getItemControl();</span>
<span class="nc bnc" id="L59" title="All 4 branches missed.">        if (planItemControl != null &amp;&amp; planItemControl.getRequiredRule() != null) {</span>

<span class="nc" id="L61">            boolean isRequired = true; // Having a required rule means required by default, unless the condition says otherwise</span>
<span class="nc" id="L62">            String requiredCondition = planItemControl.getRequiredRule().getCondition();</span>
<span class="nc bnc" id="L63" title="All 2 branches missed.">            if (StringUtils.isNotEmpty(requiredCondition)) {</span>
<span class="nc" id="L64">                isRequired = evaluateBooleanExpression(commandContext, planItemInstanceEntity, requiredCondition);</span>
            }
<span class="nc" id="L66">            return isRequired;</span>
        }
<span class="nc" id="L68">        return false;</span>
    }

    /**
     * Checks the given plan item to have at least one on-part.
     *
     * @param planItem the plan item to check for an on-part
     * @return true, if there is at least one on-part, false otherwise
     */
    public static boolean hasOnParts(PlanItem planItem) {
<span class="nc bnc" id="L78" title="All 4 branches missed.">        if (planItem.getEntryCriteria() != null &amp;&amp; planItem.getEntryCriteria().size() &gt; 0) {</span>
<span class="nc bnc" id="L79" title="All 2 branches missed.">            for (Criterion criterion : planItem.getEntryCriteria()) {</span>
<span class="nc bnc" id="L80" title="All 6 branches missed.">                if (criterion.getSentry() != null &amp;&amp; criterion.getSentry().getOnParts() != null &amp;&amp; criterion.getSentry().getOnParts().size() &gt; 0) {</span>
<span class="nc" id="L81">                    return true;</span>
                }
<span class="nc" id="L83">            }</span>
        }
<span class="nc" id="L85">        return false;</span>
    }

    public static boolean hasRepetitionRule(PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc bnc" id="L89" title="All 2 branches missed.">        return getRepetitionRule(planItemInstanceEntity) != null;</span>
    }

    public static boolean hasRepetitionRule(PlanItem planItem) {
<span class="nc bnc" id="L93" title="All 4 branches missed.">        return planItem.getItemControl() != null &amp;&amp; planItem.getItemControl().getRepetitionRule() != null;</span>
    }

    /**
     * Returns the repetition rule, if the given plan item instance has one, null otherwise.
     *
     * @param planItemInstanceEntity the plan item instance to check for a repetition rule
     * @return the repetition rule of the plan item, if available, null otherwise
     */
    public static RepetitionRule getRepetitionRule(PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc bnc" id="L103" title="All 6 branches missed.">        if (planItemInstanceEntity != null &amp;&amp; planItemInstanceEntity.getPlanItem() != null &amp;&amp; planItemInstanceEntity.getPlanItem().getItemControl() != null) {</span>
<span class="nc" id="L104">            return planItemInstanceEntity.getPlanItem().getItemControl().getRepetitionRule();</span>
        }
<span class="nc" id="L106">        return null;</span>
    }

    /**
     * Returns true, if the given plan item instance has a repetition rule which is based on a collection variable, false, if there is no repetition rule at
     * all or if it is not based on a collection variable.
     *
     * @param planItemInstanceEntity the plan item instance to check for a repetition rule based on a collection
     * @return true, if the plan item has a repetition rule based on a collection variable
     */
    public static boolean hasRepetitionOnCollection(PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc" id="L117">        RepetitionRule repetitionRule = getRepetitionRule(planItemInstanceEntity);</span>
<span class="nc bnc" id="L118" title="All 4 branches missed.">        return repetitionRule != null &amp;&amp; repetitionRule.hasCollectionVariable();</span>
    }

    /**
     * Returns true, if the given plan item instance has a repetition rule which is based on a collection variable, false, if there is no repetition rule at
     * all or if it is not based on a collection variable.
     *
     * @param planItem the plan item to check for a repetition rule based on a collection
     * @return true, if the plan item has a repetition rule based on a collection variable
     */
    public static boolean hasRepetitionOnCollection(PlanItem planItem) {
<span class="nc bnc" id="L129" title="All 2 branches missed.">        if (planItem.getItemControl() == null) {</span>
<span class="nc" id="L130">            return false;</span>
        }
<span class="nc bnc" id="L132" title="All 2 branches missed.">        if (planItem.getItemControl().getRepetitionRule() == null) {</span>
<span class="nc" id="L133">            return false;</span>
        }
<span class="nc" id="L135">        return planItem.getItemControl().getRepetitionRule().hasCollectionVariable();</span>
    }

    /**
     * Evaluates the collection variable name or expression given by the plan items repetition rule and returns its evaluated collection as a list.
     *
     * @param commandContext the command context to be used for evaluating the expression
     * @param planItemInstanceEntity the plan item instance to evaluate the collection variable given by its repetition rule
     * @return the collection variable value as a list of objects, might be null, if there is no repetition rule or no collection or the variable or expression
     *      evaluates to null
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    public static Iterable&lt;Object&gt; evaluateRepetitionCollectionVariableValue(CommandContext commandContext, PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc" id="L148">        RepetitionRule repetitionRule = getRepetitionRule(planItemInstanceEntity);</span>
<span class="nc bnc" id="L149" title="All 4 branches missed.">        if (repetitionRule == null || !repetitionRule.hasCollectionVariable()) {</span>
<span class="nc" id="L150">            return null;</span>
        }

<span class="nc" id="L153">        String collectionExpression = repetitionRule.getCollectionVariableName();</span>

<span class="nc bnc" id="L155" title="All 4 branches missed.">        if (!(collectionExpression.startsWith(&quot;${&quot;) || collectionExpression.startsWith(&quot;#{&quot;))) {</span>
<span class="nc" id="L156">            collectionExpression = &quot;${vars:getOrDefault('&quot; + collectionExpression + &quot;', null)}&quot;;</span>
        }

<span class="nc" id="L159">        Object collection = evaluateExpression(commandContext, planItemInstanceEntity, collectionExpression);</span>
<span class="nc bnc" id="L160" title="All 2 branches missed.">        if (collection == null) {</span>
<span class="nc" id="L161">            return null;</span>
        }

<span class="nc bnc" id="L164" title="All 2 branches missed.">        if (collection instanceof Iterable) {</span>
<span class="nc" id="L165">            return (Iterable&lt;Object&gt;) collection;</span>
        }

<span class="nc" id="L168">        throw new FlowableIllegalArgumentException(&quot;Could not evaluate collection for repetition rule on plan item with id '&quot; + planItemInstanceEntity.getId() +</span>
<span class="nc" id="L169">            &quot;', collection variable name '&quot; + repetitionRule.getCollectionVariableName() + &quot;' evaluated to '&quot; + collection +</span>
            &quot;', but needs to be a collection, an iterable or an ArrayNode (JSON).&quot;);
    }

    /**
     * Returns true, if: the given plan item instance has a repetition rule at all and if so, if it has a condition witch is satisfied and all in combination
     * with the optional max instance count attribute. If the repetition rule evaluates to true, this normally means that there should be an additional
     * instance of the plan item created.
     *
     * @param commandContext the command context in which this evaluation is taking place
     * @param planItemInstanceEntity the plan item instance entity to test for a repetition rule to evaluate to true
     * @param planItemInstanceContainer the container (usually the parent stage of the plan item instance) to get access to child plan items
     * @return true, if there is a repetition rule of the plan item instance currently evaluating to true with all of its conditions and attributes
     */
    public static boolean evaluateRepetitionRule(CommandContext commandContext, PlanItemInstanceEntity planItemInstanceEntity,
            PlanItemInstanceContainer planItemInstanceContainer) {
        
<span class="nc" id="L186">        RepetitionRule repetitionRule = getRepetitionRule(planItemInstanceEntity);</span>

<span class="nc bnc" id="L188" title="All 2 branches missed.">        if (repetitionRule != null) {</span>
            // we first check, if there is a max instance count set and if so, check, if there are enough active instances available already
<span class="nc bnc" id="L190" title="All 2 branches missed.">            if (repetitionRule.hasLimitedInstanceCount() &amp;&amp; repetitionRule.getMaxInstanceCount() &lt;=</span>
<span class="nc bnc" id="L191" title="All 2 branches missed.">                searchNonFinishedEqualPlanItemInstances(planItemInstanceEntity, planItemInstanceContainer).size()) {</span>
                // we found enough non-final plan item instances with the same plan item definition, so no need to create a new one
<span class="nc" id="L193">                return false;</span>
            }

<span class="nc" id="L196">            String repetitionCondition = repetitionRule.getCondition();</span>
<span class="nc" id="L197">            return evaluateRepetitionRule(commandContext, planItemInstanceEntity, repetitionCondition);</span>
        }
<span class="nc" id="L199">        return false;</span>
    }

    /**
     * Searches for non-finished plan item instances within the given container to be of the same plan item as the given instance.
     *
     * @param planItemInstanceEntity the plan item instance to search for instances of the same plan item within the container
     * @param planItemInstanceContainer the container to search for child plan item instances of the same plan item
     * @return the list of equal plan item instances, might be empty, but never null
     */
    public static List&lt;PlanItemInstance&gt; searchNonFinishedEqualPlanItemInstances(PlanItemInstanceEntity planItemInstanceEntity,
            PlanItemInstanceContainer planItemInstanceContainer) {

<span class="nc bnc" id="L212" title="All 4 branches missed.">        if (planItemInstanceContainer != null &amp;&amp; planItemInstanceContainer.getChildPlanItemInstances() != null) {</span>
<span class="nc" id="L213">            return planItemInstanceContainer.getChildPlanItemInstances()</span>
<span class="nc" id="L214">                .stream()</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">                .filter(pi -&gt; planItemInstanceEntity.getPlanItem() != null)</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                .filter(pi -&gt; pi.getPlanItem() != null)</span>
<span class="nc" id="L217">                .filter(pi -&gt; planItemInstanceEntity.getPlanItem().getId().equals(pi.getPlanItem().getId()))</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">                .filter(pi -&gt; !PlanItemInstanceState.isInTerminalState(pi))</span>
<span class="nc bnc" id="L219" title="All 2 branches missed.">                .filter(pi -&gt; !pi.getId().equals(planItemInstanceEntity.getId()))</span>
<span class="nc" id="L220">                .collect(Collectors.toList());</span>
        }

<span class="nc" id="L223">        return Collections.emptyList();</span>
    }

    public static boolean evaluateRepetitionRule(CommandContext commandContext, VariableContainer variableContainer, String repetitionCondition) {
<span class="nc bnc" id="L227" title="All 2 branches missed.">        if (StringUtils.isNotEmpty(repetitionCondition)) {</span>
<span class="nc" id="L228">            return ExpressionUtil.evaluateBooleanExpression(commandContext, variableContainer, repetitionCondition);</span>
        } else {
<span class="nc" id="L230">            return true; // no condition set, but a repetition rule defined is assumed to be defaulting to true</span>
        }
    }

    public static boolean isCompletionNeutralPlanItemInstance(PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc" id="L235">        return isCompletionNeutralPlanItemInstance(CommandContextUtil.getCommandContext(), planItemInstanceEntity);</span>
    }

    public static boolean isCompletionNeutralPlanItemInstance(CommandContext commandContext, PlanItemInstanceEntity planItemInstanceEntity) {
<span class="nc" id="L239">        PlanItemControl planItemControl = planItemInstanceEntity.getPlanItem().getItemControl();</span>
<span class="nc bnc" id="L240" title="All 4 branches missed.">        if (planItemControl != null &amp;&amp; planItemControl.getCompletionNeutralRule() != null) {</span>

<span class="nc" id="L242">            boolean isCompletionNeutral = true; // Having a required rule means required by default, unless the condition says otherwise</span>
<span class="nc" id="L243">            String condition = planItemControl.getCompletionNeutralRule().getCondition();</span>
<span class="nc bnc" id="L244" title="All 2 branches missed.">            if (StringUtils.isNotEmpty(condition)) {</span>
<span class="nc" id="L245">                isCompletionNeutral = ExpressionUtil.evaluateBooleanExpression(commandContext, planItemInstanceEntity, condition);</span>
            }
<span class="nc" id="L247">            return isCompletionNeutral;</span>
        }
<span class="nc" id="L249">        return false;</span>
    }

    /**
     * Returns true, if the given stage has an auto-complete condition which evaluates to true or if not, is in auto-complete mode permanently.
     *
     * @param commandContext the command context in which the method is invoked
     * @param variableContainer the variable container (most likely the plan item representing the stage or case plan model) used to evaluate the condition against
     * @param stage the stage model object to get its auto-complete condition from
     * @return true, if the stage is in auto-complete, either statically or if the condition evaluates to true
     */
    public static boolean evaluateAutoComplete(CommandContext commandContext, VariableContainer variableContainer, Stage stage) {
<span class="nc bnc" id="L261" title="All 2 branches missed.">        if (StringUtils.isNotEmpty(stage.getAutoCompleteCondition())) {</span>
<span class="nc" id="L262">            return evaluateBooleanExpression(commandContext, variableContainer, stage.getAutoCompleteCondition());</span>
        }
<span class="nc" id="L264">        return stage.isAutoComplete();</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>