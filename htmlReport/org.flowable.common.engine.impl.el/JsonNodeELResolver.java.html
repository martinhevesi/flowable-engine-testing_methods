<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JsonNodeELResolver.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jacoco.exec</a> &gt; <a href="index.source.html" class="el_package">org.flowable.common.engine.impl.el</a> &gt; <span class="el_source">JsonNodeELResolver.java</span></div><h1>JsonNodeELResolver.java</h1><pre class="source lang-java linenums">/* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.flowable.common.engine.impl.el;

import java.beans.FeatureDescriptor;
import java.math.BigDecimal;
import java.util.Date;
import java.util.Iterator;

import org.flowable.common.engine.impl.javax.el.CompositeELResolver;
import org.flowable.common.engine.impl.javax.el.ELContext;
import org.flowable.common.engine.impl.javax.el.ELException;
import org.flowable.common.engine.impl.javax.el.ELResolver;
import org.flowable.common.engine.impl.javax.el.PropertyNotWritableException;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.JsonNodeCreator;
import com.fasterxml.jackson.databind.node.ObjectNode;

/**
 * Defines property resolution behavior on JsonNodes.
 * 
 * @see CompositeELResolver
 * @see ELResolver
 */
public class JsonNodeELResolver extends ELResolver {

    private final boolean readOnly;

    /**
     * Creates a new read/write BeanELResolver.
     */
    public JsonNodeELResolver() {
<span class="nc" id="L45">        this(false);</span>
<span class="nc" id="L46">    }</span>

    /**
     * Creates a new BeanELResolver whose read-only status is determined by the given parameter.
     */
<span class="nc" id="L51">    public JsonNodeELResolver(boolean readOnly) {</span>
<span class="nc" id="L52">        this.readOnly = readOnly;</span>
<span class="nc" id="L53">    }</span>

    /**
     * If the base object is not null, returns the most general type that this resolver accepts for the property argument. Otherwise, returns null. Assuming the base is not null, this method will
     * always return Object.class. This is because any object is accepted as a key and is coerced into a string.
     * 
     * @param context
     *            The context of this evaluation.
     * @param base
     *            The bean to analyze.
     * @return null if base is null; otherwise Object.class.
     */
    @Override
    public Class&lt;?&gt; getCommonPropertyType(ELContext context, Object base) {
<span class="nc bnc" id="L67" title="All 2 branches missed.">        return isResolvable(base) ? Object.class : null;</span>
    }

    /**
     * If the base object is not null, returns an Iterator containing the set of JavaBeans properties available on the given object. Otherwise, returns null. The Iterator returned must contain zero or
     * more instances of java.beans.FeatureDescriptor. Each info object contains information about a property in the bean, as obtained by calling the BeanInfo.getPropertyDescriptors method. The
     * FeatureDescriptor is initialized using the same fields as are present in the PropertyDescriptor, with the additional required named attributes &quot;type&quot; and &quot;resolvableAtDesignTime&quot; set as
     * follows:
     * &lt;ul&gt;
     * &lt;li&gt;{@link ELResolver#TYPE} - The runtime type of the property, from PropertyDescriptor.getPropertyType().&lt;/li&gt;
     * &lt;li&gt;{@link ELResolver#RESOLVABLE_AT_DESIGN_TIME} - true.&lt;/li&gt;
     * &lt;/ul&gt;
     * 
     * @param context
     *            The context of this evaluation.
     * @param base
     *            The bean to analyze.
     * @return An Iterator containing zero or more FeatureDescriptor objects, each representing a property on this bean, or null if the base object is null.
     */
    @Override
    public Iterator&lt;FeatureDescriptor&gt; getFeatureDescriptors(ELContext context, Object base) {
<span class="nc bnc" id="L88" title="All 2 branches missed.">        if (isResolvable(base)) {</span>
<span class="nc" id="L89">            JsonNode node = (JsonNode) base;</span>
<span class="nc" id="L90">            final Iterator&lt;String&gt; keys = node.fieldNames();</span>
<span class="nc" id="L91">            return new Iterator&lt;&gt;() {</span>
                @Override
                public boolean hasNext() {
<span class="nc" id="L94">                    return keys.hasNext();</span>
                }

                @Override
                public FeatureDescriptor next() {
<span class="nc" id="L99">                    Object key = keys.next();</span>
<span class="nc" id="L100">                    FeatureDescriptor feature = new FeatureDescriptor();</span>
<span class="nc bnc" id="L101" title="All 2 branches missed.">                    feature.setDisplayName(key == null ? &quot;null&quot; : key.toString());</span>
<span class="nc" id="L102">                    feature.setName(feature.getDisplayName());</span>
<span class="nc" id="L103">                    feature.setShortDescription(&quot;&quot;);</span>
<span class="nc" id="L104">                    feature.setExpert(true);</span>
<span class="nc" id="L105">                    feature.setHidden(false);</span>
<span class="nc" id="L106">                    feature.setPreferred(true);</span>
<span class="nc bnc" id="L107" title="All 2 branches missed.">                    feature.setValue(TYPE, key == null ? &quot;null&quot; : key.getClass());</span>
<span class="nc" id="L108">                    feature.setValue(RESOLVABLE_AT_DESIGN_TIME, true);</span>
<span class="nc" id="L109">                    return feature;</span>

                }

                @Override
                public void remove() {
<span class="nc" id="L115">                    throw new UnsupportedOperationException(&quot;cannot remove&quot;);</span>
                }
            };
        }
<span class="nc" id="L119">        return null;</span>
    }

    /**
     * If the base object is a map, returns the most general acceptable type for a value in this map. If the base is a Map, the propertyResolved property of the ELContext object must be set to true by
     * this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. Assuming the base is a Map, this method will always return
     * Object.class. This is because Maps accept any object as the value for a given key.
     * 
     * @param context
     *            The context of this evaluation.
     * @param base
     *            The map to analyze. Only bases of type Map are handled by this resolver.
     * @param property
     *            The key to return the acceptable type for. Ignored by this resolver.
     * @return If the propertyResolved property of ELContext was set to true, then the most general acceptable type; otherwise undefined.
     * @throws NullPointerException
     *             if context is null
     * @throws ELException
     *             if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.
     */
    @Override
    public Class&lt;?&gt; getType(ELContext context, Object base, Object property) {
<span class="nc bnc" id="L141" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L142">            throw new NullPointerException(&quot;context is null&quot;);</span>
        }
<span class="nc" id="L144">        Class&lt;?&gt; result = null;</span>
<span class="nc bnc" id="L145" title="All 2 branches missed.">        if (isResolvable(base)) {</span>
<span class="nc" id="L146">            result = Object.class;</span>
<span class="nc" id="L147">            context.setPropertyResolved(true);</span>
        }
<span class="nc" id="L149">        return result;</span>
    }

    /**
     * If the base object is a map, returns the value associated with the given key, as specified by the property argument. If the key was not found, null is returned. If the base is a Map, the
     * propertyResolved property of the ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the
     * return value. Just as in java.util.Map.get(Object), just because null is returned doesn't mean there is no mapping for the key; it's also possible that the Map explicitly maps the key to null.
     * 
     * @param context
     *            The context of this evaluation.
     * @param base
     *            The map to analyze. Only bases of type Map are handled by this resolver.
     * @param property
     *            The key to return the acceptable type for. Ignored by this resolver.
     * @return If the propertyResolved property of ELContext was set to true, then the value associated with the given key or null if the key was not found. Otherwise, undefined.
     * @throws ClassCastException
     *             if the key is of an inappropriate type for this map (optionally thrown by the underlying Map).
     * @throws NullPointerException
     *             if context is null, or if the key is null and this map does not permit null keys (the latter is optionally thrown by the underlying Map).
     * @throws ELException
     *             if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.
     */
    @Override
    public Object getValue(ELContext context, Object base, Object property) {
<span class="nc bnc" id="L173" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L174">            throw new NullPointerException(&quot;context is null&quot;);</span>
        }
<span class="nc" id="L176">        Object result = null;</span>
<span class="nc bnc" id="L177" title="All 2 branches missed.">        if (isResolvable(base)) {</span>
<span class="nc" id="L178">            JsonNode resultNode = getResultNode((JsonNode) base, property, context);</span>
<span class="nc bnc" id="L179" title="All 4 branches missed.">            if (resultNode != null &amp;&amp; resultNode.isValueNode()) {</span>
<span class="nc bnc" id="L180" title="All 2 branches missed.">                if (resultNode.isBoolean()) {</span>
<span class="nc" id="L181">                    result = resultNode.asBoolean();</span>
<span class="nc bnc" id="L182" title="All 4 branches missed.">                } else if (resultNode.isShort() || resultNode.isInt()) {</span>
<span class="nc" id="L183">                    result = resultNode.asInt();</span>
<span class="nc bnc" id="L184" title="All 2 branches missed.">                } else if (resultNode.isLong()) {</span>
<span class="nc" id="L185">                    result = resultNode.asLong();</span>
<span class="nc bnc" id="L186" title="All 6 branches missed.">                } else if (resultNode.isBigDecimal() || resultNode.isDouble() || resultNode.isFloat()) {</span>
<span class="nc" id="L187">                    result = resultNode.asDouble();</span>
<span class="nc bnc" id="L188" title="All 2 branches missed.">                } else if (resultNode.isTextual()) {</span>
<span class="nc" id="L189">                    result = resultNode.asText();</span>
<span class="nc bnc" id="L190" title="All 2 branches missed.">                } else if (resultNode.isNull()) {</span>
<span class="nc" id="L191">                    result = null;</span>
                } else {
<span class="nc" id="L193">                    result = resultNode.toString();</span>
                }

            } else {
<span class="nc" id="L197">                result = resultNode;</span>
            }
<span class="nc" id="L199">            context.setPropertyResolved(true);</span>
        }
<span class="nc" id="L201">        return result;</span>
    }

    protected JsonNode getResultNode(JsonNode base, Object property, ELContext context) {
<span class="nc bnc" id="L205" title="All 2 branches missed.">        if (property instanceof String) {</span>
<span class="nc" id="L206">            JsonNode propertyNode = base.get((String) property);</span>
<span class="nc bnc" id="L207" title="All 2 branches missed.">            if (propertyNode != null) {</span>
<span class="nc" id="L208">                return propertyNode;</span>
            }

<span class="nc bnc" id="L211" title="All 6 branches missed.">            if (!readOnly &amp;&amp; base instanceof ObjectNode &amp;&amp; context.getContext(EvaluationState.class) == EvaluationState.WRITE) {</span>
                // The base does not have the requested property, so add it and return it, only if we are in write evaluation state
<span class="nc" id="L213">                return ((ObjectNode) base).putObject((String) property);</span>
            }
<span class="nc" id="L215">            return null;</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">        } else if (property instanceof Number) {</span>
<span class="nc" id="L217">            int requestedIndex = ((Number) property).intValue();</span>
<span class="nc bnc" id="L218" title="All 2 branches missed.">            if (requestedIndex &gt;= 0) {</span>
<span class="nc" id="L219">                return base.get(requestedIndex);</span>
            } else {
                // If the requested index is negative then lookup the element from the tail
                // using plus because requestedIndex is negative so size() + (-1) is the last element
<span class="nc" id="L223">                return base.get(base.size() + requestedIndex);</span>
            }
        } else {
<span class="nc" id="L226">            return base.get(property.toString());</span>
        }
    }

    /**
     * If the base object is a map, returns whether a call to {@link #setValue(ELContext, Object, Object, Object)} will always fail. If the base is a Map, the propertyResolved property of the
     * ELContext object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller should ignore the return value. If this resolver
     * was constructed in read-only mode, this method will always return true. If a Map was created using java.util.Collections.unmodifiableMap(Map), this method must return true. Unfortunately, there
     * is no Collections API method to detect this. However, an implementation can create a prototype unmodifiable Map and query its runtime type to see if it matches the runtime type of the base
     * object as a workaround.
     * 
     * @param context
     *            The context of this evaluation.
     * @param base
     *            The map to analyze. Only bases of type Map are handled by this resolver.
     * @param property
     *            The key to return the acceptable type for. Ignored by this resolver.
     * @return If the propertyResolved property of ELContext was set to true, then true if calling the setValue method will always fail or false if it is possible that such a call may succeed;
     *         otherwise undefined.
     * @throws NullPointerException
     *             if context is null.
     * @throws ELException
     *             if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.
     */
    @Override
    public boolean isReadOnly(ELContext context, Object base, Object property) {
<span class="nc bnc" id="L252" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L253">            throw new NullPointerException(&quot;context is null&quot;);</span>
        }
<span class="nc bnc" id="L255" title="All 2 branches missed.">        if (isResolvable(base)) {</span>
<span class="nc" id="L256">            context.setPropertyResolved(true);</span>
        }
<span class="nc" id="L258">        return readOnly;</span>
    }

    /**
     * If the base object is a map, attempts to set the value associated with the given key, as specified by the property argument. If the base is a Map, the propertyResolved property of the ELContext
     * object must be set to true by this resolver, before returning. If this property is not true after this method is called, the caller can safely assume no value was set. If this resolver was
     * constructed in read-only mode, this method will always throw PropertyNotWritableException. If a Map was created using java.util.Collections.unmodifiableMap(Map), this method must throw
     * PropertyNotWritableException. Unfortunately, there is no Collections API method to detect this. However, an implementation can create a prototype unmodifiable Map and query its runtime type to
     * see if it matches the runtime type of the base object as a workaround.
     * 
     * @param context
     *            The context of this evaluation.
     * @param base
     *            The map to analyze. Only bases of type Map are handled by this resolver.
     * @param property
     *            The key to return the acceptable type for. Ignored by this resolver.
     * @param value
     *            The value to be associated with the specified key.
     * @throws ClassCastException
     *             if the class of the specified key or value prevents it from being stored in this map.
     * @throws NullPointerException
     *             if context is null, or if this map does not permit null keys or values, and the specified key or value is null.
     * @throws IllegalArgumentException
     *             if some aspect of this key or value prevents it from being stored in this map.
     * @throws PropertyNotWritableException
     *             if this resolver was constructed in read-only mode, or if the put operation is not supported by the underlying map.
     * @throws ELException
     *             if an exception was thrown while performing the property or variable resolution. The thrown exception must be included as the cause property of this exception, if available.
     */
    @Override
    public void setValue(ELContext context, Object base, Object property, Object value) {
<span class="nc bnc" id="L289" title="All 2 branches missed.">        if (context == null) {</span>
<span class="nc" id="L290">            throw new NullPointerException(&quot;context is null&quot;);</span>
        }
<span class="nc bnc" id="L292" title="All 2 branches missed.">        if (base instanceof ObjectNode) {</span>
<span class="nc" id="L293">            setValue(context, (ObjectNode) base, property, value);</span>
<span class="nc bnc" id="L294" title="All 2 branches missed.">        } else if (base instanceof ArrayNode) {</span>
<span class="nc" id="L295">            setValue(context, (ArrayNode) base, property, value);</span>
        }
<span class="nc" id="L297">    }</span>

    protected void setValue(ELContext context, ObjectNode node, Object property, Object value) {
<span class="nc bnc" id="L300" title="All 2 branches missed.">        if (readOnly) {</span>
<span class="nc" id="L301">            throw new PropertyNotWritableException(&quot;resolver is read-only&quot;);</span>
        }
<span class="nc" id="L303">        JsonNode jsonNode = createNode(node, value);</span>
<span class="nc" id="L304">        node.set(property.toString(), jsonNode);</span>
<span class="nc" id="L305">        context.setPropertyResolved(true);</span>
<span class="nc" id="L306">    }</span>

    protected void setValue(ELContext context, ArrayNode node, Object property, Object value) {
<span class="nc bnc" id="L309" title="All 2 branches missed.">        if (readOnly) {</span>
<span class="nc" id="L310">            throw new PropertyNotWritableException(&quot;resolver is read-only&quot;);</span>
        }

<span class="nc" id="L313">        int index = toIndex(property);</span>
<span class="nc" id="L314">        JsonNode jsonNode = createNode(node, value);</span>
<span class="nc" id="L315">        node.set(index, jsonNode);</span>
<span class="nc" id="L316">        context.setPropertyResolved(true);</span>
<span class="nc" id="L317">    }</span>

    protected JsonNode createNode(JsonNodeCreator nodeCreator, Object value) {
        JsonNode jsonNode;
<span class="nc bnc" id="L321" title="All 2 branches missed.">        if (value instanceof BigDecimal) {</span>
<span class="nc" id="L322">            jsonNode = nodeCreator.numberNode((BigDecimal) value);</span>

<span class="nc bnc" id="L324" title="All 2 branches missed.">        } else if (value instanceof Boolean) {</span>
<span class="nc" id="L325">            jsonNode = nodeCreator.booleanNode((Boolean) value);</span>

<span class="nc bnc" id="L327" title="All 2 branches missed.">        } else if (value instanceof Integer) {</span>
<span class="nc" id="L328">            jsonNode = nodeCreator.numberNode((Integer) value);</span>
<span class="nc bnc" id="L329" title="All 2 branches missed.">        } else if (value instanceof Long) {</span>
<span class="nc" id="L330">            jsonNode = nodeCreator.numberNode((Long) value);</span>

<span class="nc bnc" id="L332" title="All 2 branches missed.">        } else if (value instanceof Double) {</span>
<span class="nc" id="L333">            jsonNode = nodeCreator.numberNode((Double) value);</span>

<span class="nc bnc" id="L335" title="All 2 branches missed.">        } else if (value instanceof JsonNode) {</span>
<span class="nc" id="L336">            jsonNode = (JsonNode) value;</span>
<span class="nc bnc" id="L337" title="All 2 branches missed.">        } else if (value instanceof CharSequence) {</span>
<span class="nc" id="L338">            jsonNode = nodeCreator.textNode(value.toString());</span>
<span class="nc bnc" id="L339" title="All 2 branches missed.">        } else if (value instanceof Date) {</span>
<span class="nc" id="L340">            jsonNode = nodeCreator.textNode(((Date) value).toInstant().toString());</span>
<span class="nc bnc" id="L341" title="All 2 branches missed.">        } else if (value != null) {</span>
<span class="nc" id="L342">            jsonNode = nodeCreator.textNode(value.toString());</span>

        } else {
<span class="nc" id="L345">            jsonNode = nodeCreator.nullNode();</span>

        }

<span class="nc" id="L349">        return jsonNode;</span>
    }

    protected int toIndex(Object property) {
        int index;
<span class="nc bnc" id="L354" title="All 2 branches missed.">        if (property instanceof Number) {</span>
<span class="nc" id="L355">            index = ((Number) property).intValue();</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">        } else if (property instanceof String) {</span>
            try {
<span class="nc" id="L358">                index = Integer.valueOf((String) property);</span>
<span class="nc" id="L359">            } catch (NumberFormatException e) {</span>
<span class="nc" id="L360">                throw new IllegalArgumentException(&quot;Cannot parse array index: &quot; + property, e);</span>
<span class="nc" id="L361">            }</span>
        } else {
<span class="nc" id="L363">            throw new IllegalArgumentException(&quot;Cannot coerce property to array index: &quot; + property);</span>
        }

<span class="nc" id="L366">        return index;</span>
    }

    /**
     * Test whether the given base should be resolved by this ELResolver.
     * 
     * @param base
     *            The bean to analyze.
     * @return base != null
     */
    private final boolean isResolvable(Object base) {
<span class="nc" id="L377">        return base instanceof JsonNode;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>